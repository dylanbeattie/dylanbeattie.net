---
layout: post
title: Cross-Domain Forms Authentication with ASP.NET
date: '2012-03-30T13:55:00.001+01:00'
author: Dylan Beattie
tags: 
modified_time: '2012-03-30T14:10:37.924+01:00'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-565745783546970614
blogger_orig_url: http://www.dylanbeattie.net/2012/03/cross-domain-forms-authentication-with.html
---

<p>I'm looking into splitting bits of a web application across multiple domains, so that - for example - all logins, password changes, etc. are handled at <a href="http://security.example.com/">http://security.example.com/</a>, payments and order history are handled at <a href="http://accounts.example.com/">http://accounts.example.com/</a> and so on. Just to keep things interesting, some of these apps are in .NET 2.0 and some are greenfield apps we'll be building in .NET 4.0.</p>  <p>Good news is - it's completely possible. And with IIS 7, it's apparently even <a href="http://learn.iis.net/page.aspx/244/how-to-take-advantage-of-the-iis-integrated-pipeline/#htmlrewrite_content_rewrite">possible to secure static pages, classic ASP and other non-.NET pages</a> using the same authentication mechanism.</p>  <h4>Step 1: Make sure your machineKey values are identical</h4>  <p>Each application that's going to participate in cross-domain authentication needs an identical machineKey element - this defines the encryption keys that are used to encrypt and decrypt the .ASPXAUTH cookie that contains the authenticated user data.</p>  <p>In my solution, I generated a machineKey using <a href="http://aspnetresources.com/tools/machineKey">http://aspnetresources.com/tools/machineKey</a> and then added this to the web.config files for each application individually - it goes under &lt;system.web&gt; like:</p>  <blockquote>   <p><font face="Consolas">&lt;system.web&gt;       <br />&#160;&#160;&#160; &lt;machineKey validationKey=&quot;<em><font color="#cccccc">yada yada yada</font></em>&quot; decryptionKey=&quot;<font color="#cccccc"><em>yada yada yada</em></font>&quot; validation=&quot;SHA1&quot; decryption=&quot;AES&quot; /&gt;        <br />&lt;/system.web&gt;</font></p> </blockquote>  <p>In theory, you could also define this in your machine.config or machine-level web.config file - remembering that you may have up to four of these (x86 .NET 20, x86 .NET 4.0, x64 .NET 2.0 and x64 .NET 4.0) - but I haven't tested this approach.</p>  <h4>Step 2: Configure your FormsAuthentication attributes</h4>  <p>Add this to the &lt;system.web&gt; section of the applications that are going to participate in cross-domain authentication:</p>  <blockquote>   <p><font face="Consolas">&lt;authentication mode=&quot;Forms&quot;&gt;       <br />&#160;&#160;&#160; &lt;forms loginUrl=&quot;</font><a href="https://security.example.com/login&quot;"><font face="Consolas">https://security.example.com/login&quot;</font></a><font face="Consolas"> timeout=&quot;2880&quot; domain=&quot;.example.com&quot; path=&quot;/&quot; /&gt;       <br />&lt;/authentication&gt;</font></p> </blockquote>  <p>Key points to note here:</p>  <ul>   <li>The loginUrl is an absolute reference to the site that hosts your security app - so if you try to view a secure page, it'll redirect you to this website to log in.</li>    <li>The cookie domain is set to &quot;.example.com&quot; = <em>notice the leading dot<strong>. </strong></em>That's important - it means the same cookie will be sent to example.com, something.example.com, another.url.at.example.com, and so on.</li> </ul>  <p>You'll need to make sure you're calling FormsAuthentication.SetAuthCookie(username) on your login server, but once that's done, you should be able to retrieve HttpContext.Current.User.Identity.Name from anywhere on any participating server. It is still up to you to verify that the username is valid and authorized - but this should save you a bit of plumbing when it comes to getting things working.</p>  