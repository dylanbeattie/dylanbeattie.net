---
layout: post
title: 'Restival Part 6: Who Am I, Revisited'
date: '2016-01-07T10:09:00.001Z'
author: Dylan Beattie
tags:
- restival
modified_time: '2016-01-07T10:09:04.749Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-145378883828102193
blogger_orig_url: http://www.dylanbeattie.net/2016/01/restival-part-6-who-am-i-revisited.html
redirect_from: "/2016/01/restival-part-6-who-am-i-revisited.html"

---

<p align="center"><strong>Note: code for this instalment is in </strong><a title="https://github.com/dylanbeattie/Restival/tree/v0.0.6" href="https://github.com/dylanbeattie/Restival/tree/v0.0.6"><strong>https://github.com/dylanbeattie/Restival/tree/v0.0.6</strong></a></p> <p>In <a href="http://dylanbeattie.blogspot.co.uk/2015/12/restival-part-5-who-am-i.html">the last instalment</a>, we looked at adding HTTP Basic authentication to a simple HTTP endpoint - GET /whoami - that returns information about the authenticated user.</p> <p>Well... I didn't like it. Both the OpenRasta and the WebAPI implementations felt really over-engineered, so I kept digging and discovered a few things that made everything much, much cleaner.</p> <h3>Basic auth in OpenRasta - Take 2</h3> <p>There's an HTTP Basic authentication feature baked into OpenRasta 2.5.x, but all of the classes are marked as deprecated so in my first implementation I avoided using it. After talking with Seb, the creator of OpenRasta, I understand a lot more about the rationale behind deprecating these classes - they're earmarked for migration into a standalone module, not for outright deletion, and they'll definitely remain part of the OpenRasta 2.x codebase for the foreseeable future.</p> <p>Armed with that knowledge, and the magical compiler directive <font face="Consolas"><strong>#pragma warning disable 618</strong> </font>that stops Visual Studio complaining about you using deprecated code, I switched Restival back to running on the OpenRasta NuGet package instead of my forked build, and reimplemented the authentication feature - and yes, it's much, much nicer.</p> <p>There's a RestivalAuthenticator which implements OpenRasta's IBasicAuthenticator interface - as with the other frameworks, this ends up being a really simple wrapper around the IDataStore:</p> <blockquote> <p><font face="Consolas">public class RestivalAuthenticator : IBasicAuthenticator { <br>&nbsp; private readonly IDataStore db;</font></p> <p><font face="Consolas">&nbsp; public RestivalAuthenticator(IDataStore db) { <br>&nbsp;&nbsp;&nbsp; this.db = db; <br>&nbsp; }</font></p> <p><font face="Consolas">&nbsp; public AuthenticationResult Authenticate(BasicAuthRequestHeader header) { <br>&nbsp;&nbsp;&nbsp; var user = db.FindUserByUsername(header.Username); <br>&nbsp;&nbsp;&nbsp; if (user != null &amp;&amp; user.Password == header.Password) return (new AuthenticationResult.Success(user.Username, new string[] { })); <br>&nbsp;&nbsp;&nbsp; return (new AuthenticationResult.Failed()); <br>&nbsp; }</font></p> <p><font face="Consolas">&nbsp; public string Realm { get { return ("Restival.OpenRasta"); } } <br>}</font></p></blockquote> <p>and then there's the configuration code to initialise the authentication provider. </p> <blockquote> <p><font face="Consolas">ResourceSpace.Uses.PipelineContributor&lt;AuthenticationContributor&gt;(); <br>ResourceSpace.Uses.PipelineContributor&lt;AuthenticationChallengerContributor&gt;(); <br>ResourceSpace.Uses.CustomDependency&lt;IAuthenticationScheme, BasicAuthenticationScheme&gt;(DependencyLifetime.Singleton); <br>ResourceSpace.Uses.CustomDependency&lt;IBasicAuthenticator, RestivalAuthenticator&gt;(DependencyLifetime.Transient);</font></p></blockquote> <p>This one stumped me for a while, until I realised that - unlike, say, Nancy, which just does everything by magic, you need to explicitly register both the AuthenticationContributor and the AuthenticationChallengerContributor. These are the OpenRasta components that handle the HTTP header parsing, decoding and the WWW-Authenticate challenge response, but if you don't explicitly wire them into your pipeline, your custom auth classes will never get called.</p> <h3>Basic auth in WebAPI - Take 2</h3> <p>As part of the last instalment, I wired up the <a href="http://www.lightinject.net/">LightInject</a> IoC container to my WebAPI implementation. I love LightInject, but something I had never previously realised is that <em>LightInject can do property injection on your custom attributes.<strong> </strong></em>This is a game-changer, because previously I'd been following a pattern of using purely decorative attributes - i.e. with no behaviour - and then implementing a separate ActionFilter that would check for the presence of the corresponding attribute before running some custom code - and all this just so I could inject dependencies into my filter instances.</p> <p>Well, with LightInject up and running, you don't need to do any of that - you can just put a public IService { get; set; } onto your MyCustomAttribute class, and LightInject will resolve IService at runtime and inject an instance of MyAwesomeService : IService into your attribute code. Which means the half-a-dozen classes worth of custom filters and responses from the last implementation can be ripped out in favour of a single <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.6/src/Restival.Api.WebApi/Security/RequireHttpBasicAuthorizationAttribute.cs">RequireHttpBasicAuthorizationAttribute</a> - which overrides WebAPI's built-in <strong>AuthorizeAttribute</strong> class to provide authorization header parsing, WWW-Authenticate challenge response, and hook the authentication up to our IDataStore interface.</p> <p>I'm much happier now with all four implementations, so it raises the interesting question of how much development time is really worth. Based on the code provided here, I suspect a good developer could implement HTTP Basic auth on any of these frameworks in about fifteen minutes - but something that takes fifteen minutes to implement doesn't really count if it takes you two days to work out how to do that fifteen-minute implementation.</p> <p>In forthcoming instalments, we're going to be adding hypermedia, HAL+JSON and resource expansion - as we move further away from basic HTTP capabilities and into more advanced REST/serialization/content negotiation, it'll be interesting to see how our four frameworks measure up.</p>