---
layout: post
title: 'Restival Part 5: Who Am I?'
date: '2016-01-07T10:08:00.001Z'
author: Dylan Beattie
tags:
- restival
modified_time: '2016-01-07T10:08:38.806Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-556398741710933740
blogger_orig_url: http://www.dylanbeattie.net/2016/01/restival-part-5-who-am-i.html
redirect_from: "/2016/01/restival-part-5-who-am-i.html"

---

<p align="center"><strong>NOTE: Code for this article is at <a title="https://github.com/dylanbeattie/Restival/tree/v0.0.5" href="https://github.com/dylanbeattie/Restival/tree/v0.0.5">https://github.com/dylanbeattie/Restival/tree/v0.0.5</a></strong></p> <blockquote> <p>UPDATE: The WebAPI and OpenRasta implementations described here are... inelegant. After this release, I spent a little more time and came up with something much cleaner - which you can read all about in the follow-up post <a title="http://dylanbeattie.blogspot.co.uk/2015/12/restival-part-6-who-am-i-revisited.html" href="http://dylanbeattie.blogspot.co.uk/2015/12/restival-part-6-who-am-i-revisited.html">http://dylanbeattie.blogspot.co.uk/2015/12/restival-part-6-who-am-i-revisited.html</a></p></blockquote> <p>Welcome back. It's been a very busy summer that's turned into a very busy autumn - including a fantastic couple of weeks in Eastern Europe, speaking at <a href="http://buildstuff.lt/">BuildStuff in Lithuania</a> and <a href="http://buildstuff.com.ua/">Ukraine</a>, where I met a lot of very interesting people, discussed a lot of very interesting ideas, tried a lot of very interesting food, and generally got a nice hard kick out of my comfort zone. Which is good. </p> <p><img title="If your name's not on the list, you're not coming in!" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: right; padding-top: 0px; padding-left: 0px; margin: 0px 0px 20px 20px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="If your name's not on the list, you're not coming in!" src="http://40.media.tumblr.com/bc16bc661736d3ec0077b81072bebc3e/tumblr_mxi1gmcnt01ryt88so1_1280.png" width="240" align="right" height="133">Anyway. As London starts getting frosty and festive, it's time to pick up where we left off earlier in the year with my ongoing Restival project - implementing the same API in four different .NET API frameworks (ServiceStack, NancyFX, OpenRasta and WebAPI).</p> <p>In this instalment, we're going to add two very straightforward capabilities to our API:</p> <ol> <li>HTTP Basic authentication. Clients can include a username/password in an <font face="Consolas">HTTP Authorization</font> header, and the API will verify their credentials against a simple user store. (If you're doing this in production, you'd enforce HTTPS/TLS so that credentials can't be sniffed in transit, but since this is a demonstration project and I'm optimising for readability, TLS is out of scope for now.)  <li>A /whoami endpoint, where authenticated users can GET details of their own user record. </li></ol> <p>And that's it. Sounds simple, right? OK, first things first - let's thrash out our requirements into something a little more detailed:</p> <ul> <li><strong>GET /whoami </strong>with valid credentials should return the current users' details (id, name, username) </li></ul> <p>But remember - we're building an authentication system, so we should also be testing the negative responses:</p> <ul> <li><strong>GET /whoami </strong>with invalid credentials returns 401 Unauthorized  <ul> <li>"invalid" means an unsupported scheme, an unsupported header format, invalid credential encoding, or a correctly formatted header containing an unrecognised username and/or password. </li></ul> <li><strong>GET /whoami </strong>without any credentials returns a 401 Unauthorized  <li><strong>GET /whoami </strong>without any credentials returns a WWW-Authenticate header indicating that we support HTTP Basic authentication. </li></ul> <p>The WWW-Authenticate thing is partly a node to HATEOAS, and partly there to make it easier to test things from a normal web browser. I tend to use <a href="https://www.getpostman.com/">Postman</a> for building and testing any serious HTTP services, but when it comes to quick'n'dirty API discovery and troubleshooting, I can't overstate the convenience of being able to paste something into a normal web browser and get a readable response.</p> <p>The test code is in <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.5/src/Restival.ApiTests/WhoAmIApiTestsBase.cs">WhoAmITestBase.cs</a>. Notice that in this implementation, our users are stored in a fake data store - FakeDataStore.cs - and we're actually using this class as a TestCaseSource in our tests so we maintain parity between the test data and the test coverage. </p> <p>The WhoAmI endpoint was trivial - find the current user name, look them up in the user store, and convert their user data to a WhoAmIResponse. The fun part here was the authentication. </p> <h3>A Note on Authentication vs Authorization</h3> <p>NOTE: Authentication and authorization are, strictly speaking, different things. Authentication is "who are you?", authorization is "are you allowed to do this thing?" Someone trying to enter the United States with a Libyan passport is <em>authenticated </em>- the US border service know exactly who they are - but they're not <em>authorized<strong> </strong></em>because Libyan citizens can't enter the US without a valid visa.</p> <p>In one respect, HTTP gets this exactly right - a 401 Unauthorized means "we don't know who you are", a 403 Forbidden means "we know who you are, but you're not allowed to do this." In another respect, it gets this badly wrong, because the Authentication header in the HTTP specification is called Authorization.</p> <h3>Authentication - The Best Case Scenario</h3> <p>OK, to build our secure /whoami endpoint, we need a handful of extension points in our framework. We need to:</p> <ol> <li>Validate a supplied username and password against our own credential store  <li>Indicate that specific resources require authorization, so that unauthorized requests for those resources will be rejected  <li>Determine the identity of the authenticated user when responding to an authorized request </li></ol> <p>The rest - WWW-Authenticate negotiation, decoding base64-encoded Authorization headers, returning 401 Unauthorized responses - is completely generic, so in an ideal world our framework will do all this for us; all we need to do is implement the three extension points above.</p> <p>Let's look at Nancy first, because alphabetical is as good an order as any.</p> <h3>NancyFX</h3> <p>Implementing HTTP Basic auth in NancyFX proved fairly straightforward. The first head-scratching moment I hit is that - unlike the other frameworks in this project - Nancy is so lightweight that I didn't actually have any kind of bootstrapper or initialization code anywhere, so it wasn't immediately obvious where to configure the additional pipeline steps. A bit of Googling and poking around the NancyFX source led me to the <a href="https://github.com/NancyFx/Nancy/tree/master/src/Nancy.Demo.Authentication.Basic">Nancy.Demo.Authentication.Basic</a> project, which made things a lot clearer. From this point, implementation involved:</p> <ol> <li>Add an <strong>AuthenticationBootstrapper</strong> - which Just WorkedTM without any explicit registration. I'm guessing it's invoked by <strike>magic</strike> sufficiently advanced technology, because it overrides <strong>DefaultNancyBootstrapper.</strong>  <li>Implement IUserValidator to connect Nancy to my custom user store - <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.5/src/Restival.Api.Nancy/UserValidator.cs">my implementation</a> is just a really simple wrapper around my user data store. My UserValidator depends on my IDataStore interface - and, thanks to Nancy's auto-configuration, I didn't have to explicitly register either of these as dependencies.  <li>In this bootstrapper, call pipelines.EnableBasicAuthentication() and pass in a basic authentication configuration. </li></ol> <blockquote> <p>protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines) { <br>&nbsp;&nbsp;&nbsp; base.ApplicationStartup(container, pipelines); <br>&nbsp;&nbsp;&nbsp; var authConfig = new BasicAuthenticationConfiguration(container.Resolve&lt;IUserValidator&gt;(), "Restival.Nancy"); <br>&nbsp;&nbsp;&nbsp; pipelines.EnableBasicAuthentication(authConfig); <br>}</p></blockquote> <p>Finally, the <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.5/src/Restival.Api.Nancy/WhoAmIModule.cs">WhoAmIModule</a> needs a call to <strong>this.RequiresAuthentication()</strong>, and that's it. Clean, straightforward, no real showstoppers. </p> <blockquote> <p>UPDATE: The NancyFX documentation has now been updated with a <a href="https://github.com/NancyFx/Nancy/wiki/Basic-Authentication">detailed walkthrough on enabling HTTP Basic authentication</a>&nbsp;</p></blockquote> <h3>OpenRasta</h3> <p>Adding HTTP Basic auth to OpenRasta was a lot more involved - and the reasons why provide some interesting insight into the underlying development practises of the frameworks we're comparing. In 2013, there were some major changes to the request processing pipeline used by OpenRasta. As part of these changes, the basic authentication features of OpenRasta (dating back to 2008) were marked as deprecated - and until now, nobody's contributed an up-to-date implementation, I'm guessing because none of the people using OpenRasta have needed one. Which left me with a choice - do I use the deprecated approach, contribute my own implementation, or disqualify OpenRasta? Well, disqualification would be no fun, and deprecated code means you get Resharper yelling at you all over the place, so I ended up implementing a pipeline-based HTTP Basic authorization module to the OpenRasta codebase.</p> <blockquote> <p>Whilst writing this article, I had a long and very enlightening chat with <a href="https://twitter.com/serialseb">Sebastien Lambla</a>, the creator of OpenRasta, about the current state of the project and specifically the authentication capabilities. It turns out the features marked as deprecated were intended to be migrated into a separate OpenRasta.Security module, thus decoupling authentication concerns from the core pipeline model - but this hasn't happened yet, and so the code is still in the OpenRasta core package. It's up to you, the implementer, whether to use the existing ('deprecated') HTTP authentication provider, or to roll your own based on the new pipeline approach. </p></blockquote> <p>The original pull request for this is <a href="https://github.com/openrasta/openrasta-core/pull/89">#89</a>, which is based on the Digest authentication example included in the OpenRasta core codebase - but shortly after it was accepted, I found a bug with the way both the Digest and my new Basic implementation handled access to non-secured resources. The fix for this is in <a href="https://github.com/openrasta/openrasta-core/pull/91">#91</a>, which at the time of writing is still being reviewed, so Restival's currently building against my fork of OpenRasta in order to get the authentication and WhoAmI tests passing properly.</p> <p>Following those changes to the framework itself, the implementation was pretty easy.</p> <ol> <li>Provide an <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.5/src/Restival.Api.OpenRasta/AuthenticationProvider.cs">implementation of IAuthenticationProvider</a> based on my IDataStore interface.  <li>Register the authentication provider and pipeline contributor in the Configuration class: <br><br><font face="Consolas">ResourceSpace.Uses.CustomDependency&lt;IDataStore, FakeDataStore&gt;(DependencyLifetime.Singleton); <br>ResourceSpace.Uses.CustomDependency&lt;IAuthenticationProvider, AuthenticationProvider&gt;(DependencyLifetime.Singleton); <br>ResourceSpace.Uses.PipelineContributor&lt;BasicAuthorizerContributor&gt;(); </font><br> <li>Decorate the <a href="https://github.com/dylanbeattie/Restival/blob/v0.0.5/src/Restival.Api.OpenRasta/Handlers/WhoAmIHandler.cs">WhoAmIHandler</a> with <strong>[RequiresBasicAuthentication(realm)]</strong> </li></ol>Total research and Google time took the best part of a day - including implementing the missing pieces of the framework. Implementation time once those were in place was around an hour, although I suspect even if the necessary authorization components already existed I'd have needed a couple of hours Google time to work out exactly how to plug into the pipeline.&nbsp;&nbsp; <h3>&nbsp;</h3> <h3>ServiceStack</h3> <p>Service was really straightforward, mainly because the extension points for overriding built-in authentication behaviour are logical and <a href="https://github.com/ServiceStack/ServiceStack/wiki/Authentication-and-authorization">clearly documented</a>. Implementation involved creating my own AuthProvider that extends the built-in BasicAuthProvider, injecting an IDataStore into this auth provider, and then registering my provider with ServiceStack in AppHost.Configure().</p> <p>The only gotcha I encountered here was that the first implementation would response with an HTTP redirect to a login page if the request wasn't authorized - but Googling "<a href="https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=servicestack+authentication+redirecting+to+/login">servicestack authentication redirecting to /login</a>" brought up <a href="http://stackoverflow.com/questions/13065289/when-servicestack-authentication-fails-do-not-redirect">this StackOverflow post</a>, which explained that (a) this only happens for HTML content-type requests (my fault for using a web browser to test my HTTP API, I guess!), and that you can disable it by specifying HtmlRedirect = null when you initialize the auth feature:</p> <blockquote> <p><font face="Consolas">public class AppHost : AppHostBase { <br>&nbsp; public AppHost() : base("Restival", typeof(HelloService).Assembly) { } <br>&nbsp; public override void Configure(Container container) { <br>&nbsp;&nbsp;&nbsp; var db = new FakeDataStore(); <br>&nbsp;&nbsp;&nbsp; container.Register&lt;IDataStore&gt;(c =&gt; db).ReusedWithin(ReuseScope.Container); <br></font><font face="Consolas">&nbsp;&nbsp;&nbsp; var auth = new AuthFeature(() =&gt; new AuthUserSession(), new IAuthProvider[] { new RestivalAuthProvider(db) }) { <br>&nbsp; <font style="background-color: #ffff00">&nbsp;&nbsp;&nbsp; </font><strong><font style="background-color: #ffff00">HtmlRedirect = null <br></font></strong>&nbsp;&nbsp;&nbsp; }; <br>&nbsp;&nbsp;&nbsp; Plugins.Add(auth); <br>&nbsp; } <br>}</font></p></blockquote> <p>Total implementation time was about half an hour here - but bear in mind I've worked with ServiceStack a lot, so I'm familiar with the plugin architecture and the pipeline. </p> <h3>WebAPI</h3> <p>It took a surprisingly long time to come up with an HTTP Basic auth implementation on WebAPI. The first stumbling block here was the sheer number of posts, articles and examples demonstrating how to do it. There's a lot of excellent resources online about adding HTTP Basic authentication support to WebAPI, most of which are subtle variations on a common theme:</p> <ul> <li><a href="https://github.com/RickStrahl/WestwindToolkit/tree/master/Westwind.Web.WebApi">Rick Strahl's WestwindToolkit</a>  <li><a href="http://www.asp.net/web-api/overview/security/authentication-filters">Authentication Filters in ASP.NET Web API 2</a> on <a href="http://www.asp.net">www.asp.net</a>  <li>Robert Muehsig's <a href="http://blog.codeinside.eu/2015/04/17/basic-authentication-in-aspnet-webapi/">Using Basic Authentication in ASP.NET WebAPI</a> (and the associated <a href="https://github.com/Code-Inside/Samples/tree/master/2015/WebApiBasicAuth">code on GitHub</a>)  <li>Jamie Kurtz' <a href="https://github.com/jamiekurtz/BasicAuthForWebAPI">BasicAuthForWebAPI</a> (based on the ASP.NET membership provider)  <li>"<a href="http://stackoverflow.com/questions/26464848/custom-authorization-in-asp-net-webapi-what-a-mess">Custom Authorization in ASP.NET WebAPI - What A Mess?</a>" on StackOverflow </li></ul> <p>Now, the optimal number of references in a scenario like this is <em>one</em>. A single article, ideally written by the framework authors, saying "this is how you implement this very simple thing", and identifying the available integration points. Any framework where 3+ people have written in-depth articles on how to add something as simple as HTTP Basic authentication is insufficiently opinionated. Then there's the realization that WebAPI follows the ASP.NET MVC convention of decorating controllers and actions with attributes to support features like authentication - and injecting dependencies into attributes is <em>fiddly,</em> because of the way that attributes are instantiated by the runtime. So... fast-forward several hours of Googling and forking and compiling things and generally poking around, and I decided that Robert Muehsig's approach is the closest thing to what I'm after. And since it's on GitHub under an MIT license, I borrowed it. Most of the classes in <a href="https://github.com/dylanbeattie/Restival/tree/v0.0.5/src/Restival.Api.WebApi/Security">Restival.Api.WebApi.Security</a> are lifted directly from Robert's sample code. This produced a working implementation that passed all the tests, but I must admit I'm still not happy with it. It's definitely one I plan to revisit. It's notable that this implementation explicitly decouples the attribute itself from the filter implementation - this is so I can inject dependencies into the filter at runtime whilst still using the attribute declaratively, but it's rather inelegant and I can't say I'm terribly happy with it.</p> <p>Total implementation time for this was at least a day, including research, reading examples, prototyping and digging into the WebAPI source to work out which bits to override. That's significantly more than I thought it would be, and I'm rather expecting someone to comment on this post "you're doing it wrong!" and link me to ANOTHER blog post or web page which demonstrates a different approach that "only takes five minutes". We shall see. :)</p> <h3>Conclusions</h3> <p>Here's how the four authentication implementations stack up. The implementation time here isn't how long it took, it's how long I think it would take to do it again now I'm familiar with the various frameworks authentication/plugin patterns. </p> <table cellspacing="0" cellpadding="8" width="923" border="1"> <tbody> <tr> <td valign="top" width="134"><strong>Framework</strong></td> <td valign="top" width="213"><strong>Lines of code</strong></td> <td valign="top" width="226"><strong>New Classes</strong></td> <td valign="top" width="143"><strong>Research time</strong></td> <td valign="top" width="205"><strong>Implementation Time </strong></td></tr> <tr> <td valign="top" width="134">WebAPI</td> <td valign="top" width="213">~ 250</td> <td valign="top" width="226">6 (<a href="https://github.com/dylanbeattie/Restival/tree/v0.0.5/src/Restival.Api.WebApi/Security">here</a>)</td> <td valign="top" width="143">1 day</td> <td valign="top" width="205">2-3 hours</td></tr> <tr> <td valign="top" width="134">ServiceStack</td> <td valign="top" width="213">~ 20</td> <td valign="top" width="226">1 (RestivalAuthProvider)</td> <td valign="top" width="143">15 minutes</td> <td valign="top" width="205">15 mins</td></tr> <tr> <td valign="top" width="134">NancyFX</td> <td valign="top" width="213">~ 25</td> <td valign="top" width="226">2 (UserIdentity, UserValidator)</td> <td valign="top" width="143">30 minutes</td> <td valign="top" width="205">15 mins</td></tr> <tr> <td valign="top" width="134">OpenRasta</td> <td valign="top" width="215">~ 30 <br><br><em>plus changes to framework </em></td> <td valign="top" width="233">1 (AuthenticationProvider) <br><br><em>plus two new framework classes</em></td> <td valign="top" width="143">1 day</td> <td valign="top" width="205">1-2 hours</td></tr></tbody></table> <p>HTTP Basic auth proved an interesting example, because whilst it's an obvious feature on any API feature 'checklist', any reasonably mature HTTP API will almost certainly have moved beyond basic authentication to something more sophisticated such as per-client API keys or OAuth2 tokens.&nbsp; </p> <p>When it comes to ease of implementation, I'd say it's a dead heat between NancyFX and ServiceStack. I have more experience working with ServiceStack than I do with Nancy, and I suspect my familiarity with their plugin model made things a little easier, but I really don't think there's much in it - the integration points are sensible, the documentation is comprehensive (and accurate!), and I'm pretty confident the implementations presented here reflect the idioms of the corresponding platforms.</p> <p>OpenRasta and WebAPI were much less straightforward, but for very different reasons, In a nutshell, I think WebAPI is insufficiently opinionated - rather than encouraging or enforcing a particular approach, it supports a wealth of different integration patterns and extension points, and it's really not clear why any one is better than another. OpenRasta, on the other hand, has a very strong authentication pattern that makes a lot of sense once you get your head around it - but a lack of examples and up-to-date documentation means it's quite hard to work out what the pattern is without digging into the framework source code and getting your hands dirty.</p> <p>Tune in next time, when we're going to start adding hypermedia to our /whoami endpoint response.</p> <p><em>Thanks to </em><a href="https://twitter.com/jchannon"><em>Jonathan Channon</em></a><em>, </em><a href="https://twitter.com/grumpydev"><em>Steven Robbins</em></a><em> and </em><a href="https://twitter.com/serialseb"><em>Sebastien Lambla</em></a><em> for their help and feedback on this instalment.</em></p>