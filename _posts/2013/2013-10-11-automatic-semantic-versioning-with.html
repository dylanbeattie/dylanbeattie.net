---
layout: post
title: Automatic Semantic Versioning with GitHub and TeamCity
date: '2013-10-11T20:20:00.001+01:00'
author: Dylan Beattie
tags: 
modified_time: '2013-10-11T20:44:22.963+01:00'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-3895507098864324667
blogger_orig_url: http://www.dylanbeattie.net/2013/10/automatic-semantic-versioning-with.html
redirect_from: "/2013/10/automatic-semantic-versioning-with.html"

---

<p style="line-height: normal; margin: 0cm 0cm 0pt; background: white; text-autospace: ; mso-layout-grid-align: none" class="MsoNormal" align="left"></p>  <p style="line-height: 13pt; margin: 0cm 0cm 10pt" class="MsoNormal" align="left"><font face="Calibri"><font style="font-size: 11pt" color="#000000"></font></font></p> You’ve quite possibly come across the idea of <a href="http://semver.org/spec/v2.0.0.html">semantic versioning</a>. It's a set of rules for versioning releases of software, designed to minimise disruption to people who are relying on your APIs not to change. In a nutshell, every release of your software has a three-part version number.    <blockquote>   <p><strong>Given a version number MAJOR.MINOR.PATCH, increment the:</strong></p>    <ol>     <li><strong>MAJOR version when you make incompatible API changes, </strong></li>      <li><strong>MINOR version when you add functionality in a backwards-compatible manner, and </strong></li>      <li><strong>PATCH version when you make backwards-compatible bug fixes.</strong> </li>   </ol>    <p><strong>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.</strong></p> </blockquote>  <p>Pretty simple, huh? In other words, 2.3.4 should offer the same feature set as 2.3.1 but with extra bug fixes. 2.4.0 is backwards-compatible with 2.3.2, and with 2.2.*, and with 2.1.*, and when you go for the ‘big rewrite’ and break everything, that’s version 3.0.0 which isn’t compatible with any previous versions.</p>  <p>Our main development pipeline is now based on TeamCity 8 and GitHub – both of which are absolutely wonderful once you get the hang of using them properly – and I wanted to automate the versioning of our builds according to semantic versioning principles. Here’s the workflow I settled on:</p>  <ul>   <li>Every build has a MAJOR, MINOR, PATCH, and BUILD version, and an optional SUFFIX </li>    <li>Each part of the version number is managed as a TeamCity build parameter. </li>    <li>MAJOR and MINOR are managed manually. TeamCity can’t tell whether your commit is a feature or a bugfix, so for now we’ve just settled for manually changing the relevant parameters when you release a major or minor release. </li>    <li>All development is done on feature branches and submitted via pull requests. </li>    <li>Any pull request is assumed to be a PATCH release unless a developer changes the major or minor numbers when they accept it. </li>    <li>The SUFFIX is used to denote a pre-release package, and should indicate which branch’s features are included in that prerelease      <ul>       <li>e.g. Dylan.Web-1.2.3.0-branch7 should be the code you’d get if you accepted branch7 into master 1.2.3 </li>     </ul>   </li>    <li>Anything built off <strong>master</strong> should be releasable, and tagged as such </li>    <li>Finally, whenever a production release is built, we’ll tag the GitHub repository with the version of that release – for tagging, we ignore the build number, so the tag will be something like <strong>v0.0.0</strong> </li> </ul>  <p>This lot actually distils to quite a simple guideline: <strong>The patch number is the number of pull requests accepted since the last tagged minor release. </strong></p>  <p>Now <em>that </em>sounds like something you could automate… so with Powershell on one screen and the Github API documentation on the other, I hacked together the following script, which is now happily running as a build step on our TeamCity server.</p>  <blockquote>   <p align="left"><font face="Consolas">$MajorVersion = %MajorVersion% # The major version of your current build        <br />$MinorVersion = %MinorVersion% # The minor version of your current build         <br />$RepoUrl = &quot;%vcsroot.url%&quot; # The HTTPS path to your repo – <a href="https://github.com/MyCompany/MyRepository.git">https://github.com/MyCompany/MyRepository.git</a>         <br />$Token = &quot;%GitHubAccessToken%&quot; # Your GitHub access token, from <a href="https://github.com/settings/applications">https://github.com/settings/applications</a></font></p>    <p align="left"><font face="Consolas">try {        <br />&#160;&#160;&#160; # Parse the supplied Git repo URL to determine the repo name and owner         <br />&#160;&#160;&#160; $RepoUrl -match &quot;</font><a href="https://github.com/([^/]+)/(.+)\.git"><font face="Consolas">https://github.com/([^/]+)/(.+)\.git</font></a><font face="Consolas">$&quot;        <br />&#160;&#160;&#160; $repoOwner = $matches[1]         <br />&#160;&#160;&#160; $repoName = $matches[2]         <br />&#160;&#160;&#160; Write-Host &quot;Reading repo $repoName owned by $repoOwner&quot;         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; # Find the tag resource matching the baseline of the current major/minor version         <br /></font><font face="Consolas">&#160;&#160;&#160; # Remember, we’re not looking for X.Y.Z, we’re looking for X.Y.0 since patch numbers        <br />&#160;&#160;&#160; # should increment until the next minor release.         <br /></font><font face="Consolas">       <br />&#160;&#160;&#160; $uri = &quot;</font><a href="https://api.github.com/repos/"><font face="Consolas">https://api.github.com/repos/</font></a><font face="Consolas">$repoOwner/$repoName/git/refs/tags/v$MajorVersion.$MinorVersion.0?access_token=$Token&quot;        <br />&#160;&#160;&#160; Write-Output &quot;Looking for tag v$MajorVersion.$MinorVersion.0 at $uri&quot;         <br />&#160;&#160;&#160; $tag = Invoke-RestMethod -Uri &quot;$uri&quot;</font></p>    <p align="left"><font face="Consolas">&#160;&#160;&#160; # $tag.object.url will now give us a more detailed tag resource, including the commit that was tagged        <br />&#160;&#160;&#160; $uri = $tag.object.url         <br />&#160;&#160;&#160; Write-Output &quot;Getting tag info from $uri`?access_token=$Token&quot;         <br />&#160;&#160;&#160; $tag = Invoke-RestMethod -Uri &quot;$uri`?access_token=$Token&quot;         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; # $tag.object.url is now a link to the tagged commit         <br />&#160;&#160;&#160; $uri = $tag.object.url         <br />&#160;&#160;&#160; $tag = Invoke-RestMethod -Uri &quot;$uri`?access_token=$Token&quot;</font></p>    <p align="left"><font face="Consolas">&#160;&#160;&#160; # now we can dig into the commit itself and find out WHEN the baseline release was tagged...        <br />&#160;&#160;&#160; $since = $tag.committer.date</font></p>    <p align="left"><font face="Consolas">&#160;&#160;&#160; # Now we can retrieve all the commits in this repo SINCE that date        <br />&#160;&#160;&#160; $commitsUri = &quot;</font><a href="https://api.github.com/repos/"><font face="Consolas">https://api.github.com/repos/</font></a><font face="Consolas">$repoOwner/$repoName/commits?since=$since&amp;access_token=$Token&quot;        <br />&#160;&#160;&#160; Write-Host &quot;Retrieving commit log from $commitsUri&quot;         <br />&#160;&#160;&#160; $commits = Invoke-RestMethod -Uri &quot;$commitsUri&quot;         <br />&#160;&#160;&#160; $merges = @($commits | Where-Object { $_.commit.message -match &quot;^Merge pull request&quot; })         <br />        <br />&#160;&#160;&#160; # Reversing the merges just means they show up in TeamCity’s build log in chronological order.         <br />&#160;&#160;&#160; # Which is nice.         <br />&#160;&#160;&#160; [Array]::Reverse($merges)         <br />        <br /></font><font face="Consolas">&#160;&#160;&#160; $mergeCount = $merges.Count        <br />&#160;&#160;&#160; Write-Host &quot;Found $mergeCount merges since last release tag&quot;         <br />&#160;&#160;&#160; for($i = 0; $i -lt $merges.Count; $i++) {         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $merge_number = $i+1         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $merge_message = $merges[$i].commit.message.split(&quot;`r`n&quot;,[StringSplitOptions]&quot;RemoveEmptyEntries&quot;) -join &quot;`r`n&#160;&#160;&#160; &quot;         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $merge_sha = $merges[$i].sha         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $merge_web_url = $RepoUrl.Replace(&quot;.git&quot;, &quot;/commit/$merge_sha&quot;)         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;`r`n&#160; Merge #$merge_number`: $merge_web_url&quot;         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&#160;&#160;&#160; $merge_message&quot;         <br />&#160;&#160;&#160; }         <br />&#160;&#160;&#160; Write-Host &quot;`r`n&quot;         <br />&#160;&#160;&#160; Write-Output &quot;##teamcity[setParameter name='PatchVersion' value='$mergeCount']&quot;         <br />} catch [System.Exception] {         <br />&#160;&#160;&#160; Write-Host &quot;Exception trying to determine patch number from Github API&quot;         <br />&#160;&#160;&#160; Write-Host $_         <br />&#160;&#160;&#160; Write-Host &quot;Using default patch number 0&quot;         <br />&#160;&#160;&#160; Write-Output &quot;##teamcity[setParameter name='PatchVersion' value='0']&quot;         <br />}</font></p> </blockquote>  <p>A couple of fun details to look out for:</p>  <ul>   <li>If we’re doing the first build of a new minor version, there won’t <strong>be</strong> any ‘baseline’ tagged version yet – which is fine; we just set the patch number to zero and off we go. </li>    <li>You can control TeamCity build parameters by outputting specially-formatted messages in your build log – that’s what those lines      <br />      <br /><font size="2" face="Consolas">Write-Output &quot;##teamcity[setParameters name='SomeParameter' value='NewValue']&quot;</font>       <br />      <br />are doing. See <a href="http://confluence.jetbrains.com/display/TCD7/Build+Script+Interaction+with+TeamCity#BuildScriptInteractionwithTeamCity-AddingorChangingaBuildParameter">Build Script Interaction with TeamCity</a> for more info. </li> </ul>  <p>Finally, if you'd like the commit/merge hyperlinks in your TeamCity build log to be clickable, check out this awesome tip from Christian Rodemeyer about <a href="http://atombrenner.blogspot.co.uk/2012/09/embed-url-links-in-teamcity-build-logs.html">how to embed clickable URL links in TeamCity build logs</a>.</p>  <p>Happy versioning!</p>  