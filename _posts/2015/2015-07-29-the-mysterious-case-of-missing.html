---
layout: post
title: The Mysterious Case of the Missing Milliseconds
date: '2015-07-29T22:15:00.001+01:00'
author: Dylan Beattie
tags: 
modified_time: '2015-07-29T22:21:53.490+01:00'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-1200191661615090960
blogger_orig_url: http://www.dylanbeattie.net/2015/07/the-mysterious-case-of-missing.html
redirect_from: "/2015/07/the-mysterious-case-of-missing.html"

---

<p>Strings are the <em>lingua franca</em> of many distributed systems, and Spotlight is no different. Earlier today, we hit a weird head-scratching bug in one of our services, and - surprise, surprise - turns out it's all do with strings. To work around limitations of an old line-of-business application, we have a database trigger (no, really) that captures changes made to a particular table, serializes them into an XML message, and pushes this into a SQL Service Broker queue; we then have a Windows service that pulls messages off the queue, parses the XML, breaks it into nicely manageable chunks and publishes them all to RabbitMQ using EasyNetQ. SImple. Except, once in a while, it blows up and starts complaining about <strong>FormatException</strong>s.</p>  <p>Now... within the database trigger, we're doing this:</p>  <blockquote>   <p><font face="Consolas">SELECT @OccurredAtUtc = CONVERT(VARCHAR(128), GETUTCDATE(), 126)</font></p> </blockquote>  <p>which returns <strong>2015-07-29T20:55:21.130 </strong>as you'd expect.</p>  <p>There's then a line of code in the Windows service that says:</p>  <blockquote>   <p><font face="Consolas">var format = &quot;yyyy-MM-ddTHH:mm:ss.fff&quot;;       <br /></font><font face="Consolas">DateTime.ParseExact(d, format, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);</font></p> </blockquote>  <p>Now, this is the code of somebody who knows that turning datetimes into strings and back again can get a bit tricky, and so has left absolutely nothing to chance - they've supplied an exact date format, they've specified a culture, they've even gone so far as to specify the DateTimeStyles. There's unit tests and integration tests, and everything looks absolutely lovely. And then it blows up. Very occasionally, </p>  <p>Except... SQL Server does something weird.</p>  <blockquote>   <p><font face="Consolas">DECLARE @DateTime DATETIME        <br />SELECT @DateTime = '2015-07-29 21:59:15:123'         <br />SELECT CONVERT(VARCHAR(128), @DateTime, 126) -- returns 2015-07-29T21:59:15.123 (fine!)</font></p>    <p><font face="Consolas">SELECT @DateTime = '2015-07-29 21:59:15:000'        <br />SELECT CONVERT(VARCHAR(128), @DateTime, 126) -- returns 2015-07-29T21:59:15</font></p>    <p><font face="Consolas">SELECT @DateTime = '2015-07-29 21:59:15:999'        <br />SELECT CONVERT(VARCHAR(128), @DateTime, 126) -- returns 2015-07-29T21:59:16</font></p>    <p><font face="Consolas">SELECT @DateTime = '2015-07-29 21:59:15:001'        <br />SELECT CONVERT(VARCHAR(128), @DateTime, 126) -- returns 2015-07-29T21:59:15</font></p> </blockquote>  <p>First, SQL Server doesn't have true millisecond precision - the milliseconds part will often get rounded by +- 0.001 seconds. Second - if the milliseconds part is zero, <strong>it'll be omitted from the string representation</strong>. Which means our incredibly specific and detailed date parsing routine will choke, because suddenly it has a date that doesn't match the format we've specified, and DateTime.ParseExact will throw a FormatException. Unit tests don't pick it up, because why would you mock such completely bizarre (and undocumented) behaviour, when you don't even know it exists? </p>  <p>What this means is that, since any changes done between .999 and .001 milliseconds will blow up, roughly 0.3% of all our transactions will be failing with a FormatException rather than getting synced to the rest of our systems. Which means fishing them out of the error queue and sorting them out manually - ah, the joy of distributed systems. This formatting weirdness happens on every version of SQL back as far as 2003, but there's no reference to it in <a href="https://msdn.microsoft.com/en-us/library/ms187928(v=sql.110).aspx">the documentation</a> until SQL Server 2012. It's been <a href="https://connect.microsoft.com/SQLServer/feedback/details/714388">raised as a bug</a> and closed as 'by design' because &quot;the ISO 8601 spec leaves the conversion semantics for fractional seconds up to the implementation&quot; - which I'm pretty sure didn't mean &quot;go ahead and be internally inconsistent!&quot; but as with so many other issues like this, fixing the bug would change behaviour that's been in place for years and could break things. I've no idea how - or why - anyone would build a system that genuinely relies on this bizarre idiosyncrasy, but I'll bet good money somebody out there has done it.</p>  <p>The beautiful irony, of course, is that if we'd used DateTime.Parse instead of ParseExact, we'd never have had a problem. :)</p>  