---
layout: post
title: 'Restival Part 2: All Aboard The Routemaster'
date: '2015-05-04T22:24:00.001+01:00'
author: Dylan Beattie
tags:
- patterns
- asp.net
- rest
- architecture
- restival
modified_time: '2015-05-04T22:31:29.997+01:00'
thumbnail: http://lh3.googleusercontent.com/-cLrtXlIKCW8/VUfjhPn40JI/AAAAAAAADqU/D0f-nVsnp-k/s72-c/image_thumb%25255B2%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-8775626485167757375
blogger_orig_url: http://www.dylanbeattie.net/2015/05/restival-part-2-all-aboard-routemaster.html
---

<p>Hello, and welcome to the second instalment of Restival: The Great .NET ReST Showdown <a href="http://dylanbeattie.blogspot.co.uk/2015/04/one-api-four-frameworks-great-net-rest.html">(part 1 is here if you missed it</a>)&#160; So far, our API defines a single very simple method – “hello”. Making a GET request to /hello will return <font face="Consolas"><strong>{ &quot;Message&quot; : &quot;Hello, World!&quot; }</strong></font>, and making a GET request to /hello/chris will return <font face="Consolas"><strong>{ &quot;Message&quot; : &quot;Hello, Chris!&quot; }</strong></font></p>  <p>The code we're discussing here is <a href="https://github.com/dylanbeattie/Restival/releases/tag/v0.0.1">on GitHub as release v0.0.1</a>. This release supports <strong>/hello/{name}</strong>, which demonstrates routing and parameter binding. I've deliberately not implemented &quot;Hello, World&quot; at <strong>/hello</strong> yet,&#160;&#160; because I want to do that by using the various frameworks' conventions for specifying default parameter values and that logically can't happen until you've defined your routes. Even at this incredibly early stage, there's some interesting design decisions going on. </p>  <h4>Routing and Route Binding</h4>  <p>Routing controls how your app will map incoming HTTP requests to methods - it's the set of rules that say &quot;when you get a request that looks like X, run method Y on class Z&quot;</p>  <p>Nancy has a really lightweight routing syntax inspired by <a href="http://www.sinatrarb.com/">Sinatra</a> - by inheriting from NancyModule, you get access to a RouteBuilder, a sort of dictionary that maps routes to anonymous methods, for each supported HTTP verb (<code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>POST</code>, <code>PUT</code> and <code>PATCH</code>) - to add a route, you supply the pattern to match and the method implementation:</p>  <blockquote>   <p>public class HelloModule : NancyModule {     <br />&#160;&#160;&#160; public HelloModule() {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Get[&quot;/hello/{name}&quot;] = parameters =&gt; new Greeting(parameters.name);      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>Note the Nancy convention whereby we use an underscore to indicate &quot;we're not using this variable for anything&quot; in handlers that don't actually use their parameter dictionary. It's also worth noting that Nancy's lightweight syntax won't stop you defining multiple handlers for the same route - but this <a href="https://github.com/NancyFx/Nancy/wiki/Defining-routes#the-secret-for-selecting-the-right-route-to-invoke">can lead to non-deterministic behaviour</a>, so don't do it :)</p>  <p>WebAPI uses an explicit routing table that's configured during application startup - in WebAPI, there's a call to <font face="Consolas">WebApiConfig.Register(GlobalConfiguration.Configuration) </font>in Application_Start, and routes are mapped by specifying the name, the URL pattern and the defaults to use for that route. (If you're familiar with routing in ASP.NET MVC, WebAPI uses a very similar routing configuration, but with the 'action' mapped to the HTTP verb instead of to a path segment.)</p>  <blockquote>   <p>config.Routes.MapHttpRoute(     <br />&#160;&#160;&#160; &quot;Hello&quot;,&#160;&#160; // route name      <br />&#160;&#160;&#160; &quot;hello/{name}&quot;, // route template      <br />&#160;&#160;&#160; new { Controller = &quot;Hello&quot; } // route defaults      <br />);</p> </blockquote>  <p>OpenRasta and ServiceStack are both far more explicit about the relationship between resources, routes and handlers. OpenRasta uses a fluent configuration interface to declare your <strong>resources</strong> (i.e. the bits of data we're interested in), your URIs (routes), handlers (the bits of code that actually do the work), and contracts (which handle things like serialization and content types)</p>  <blockquote>   <p>public class Configuration : IConfigurationSource {     <br />&#160;&#160;&#160; public void Configure() {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; using (OpenRastaConfiguration.Manual) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ResourceSpace.Has.ResourcesOfType&lt;Greeting&gt;()      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; AtUri(&quot;/hello/{name}&quot;)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HandledBy&lt;HelloHandler&gt;()      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .AsJsonDataContract();      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>Finally, ServiceStack requires you to explicitly define <strong>requests </strong>(DTOs representing the incoming request data)<strong>, services (</strong>analogous to handlers in our other frameworks) and <strong>responses</strong>. This is far more verbose than the other frameworks, but providing these abstraction layers between every aspect of your ReST API and your underlying codebase gives you more flexibility to evolve your API independently of the underlying business logic. You map your routes to your request DTOs using the <strong>Route</strong> attribute, and inherit from <strong>ServiceStack.Service</strong> when implementing your handlers. ServiceStack maps HTTP verbs onto service method names - <font face="Consolas">HelloService.Get(Hello dto), HelloService.Post(Hello dto)</font>, etc. - but also supports a catch-all Any() method which will map incoming requests regardless of the request verb.</p>  <blockquote>   <p>[Route(&quot;/hello&quot;)]     <br />[Route(&quot;/hello/{name}&quot;)]      <br />public class Hello {      <br />&#160;&#160;&#160; public string Name { get; set; }      <br />}</p>    <p>public class HelloResponse {     <br />&#160;&#160;&#160; public string Message { get; set; }      <br />}</p>    <p>public class HelloService : Service {     <br />&#160; public HelloResponse Any(Hello dto) {      <br />&#160;&#160;&#160; var greeting = new Greeting(dto.Name);      <br />&#160;&#160;&#160; var response = new HelloResponse() { Message = greeting.Message };      <br />&#160;&#160;&#160; return (response);      <br />&#160; }      <br />}</p> </blockquote>  <p>So there you go. <strong>/hello/{name}</strong> takes one line in NancyFX, a couple of lines in OpenRasta and WebAPI, and three entire classes in ServiceStack. Before you draw any conclusions, though, try pointing a browser at the root URL of each API implementation. </p>  <p>Nancy gives you this rather splendid 404 page - complete with <a href="http://theoatmeal.com/comics/state_web_summer#tumblr">Tumbeast</a>:</p>  <p><a href="http://lh3.googleusercontent.com/-rhJ2mrWMcNg/VUfjgjuI2DI/AAAAAAAADqQ/jzQv3xhqZVU/s1600-h/image%25255B4%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="image" src="http://lh3.googleusercontent.com/-cLrtXlIKCW8/VUfjhPn40JI/AAAAAAAADqU/D0f-nVsnp-k/image_thumb%25255B2%25255D.png?imgmax=800" width="640" height="423" /></a></p>    <p>Running under IIS, WebAPI and OpenRasta both interpret GET / as a directory browse request, and give you the all-too-familiar IIS 7.5 HTTP error screen:</p>  <p><a href="http://lh3.googleusercontent.com/-_cDqXY6-wxo/VUfjhs8ti3I/AAAAAAAADqg/BwohqHSRArY/s1600-h/image%25255B9%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="image" src="http://lh3.googleusercontent.com/-2YtSPRQHUDM/VUfjii3B_xI/AAAAAAAADqk/_kBxcHDbJJI/image_thumb%25255B5%25255D.png?imgmax=800" width="640" height="423" /></a></p>  <p>But the pay-off for the extra boilerplate required by ServiceStack is this rather nice API documentation page, describing the services and encoding formats supported by the API and providing WSDL files for adding our API as a service endpoint. Now, we're not actually <em>using </em>any of that yet... but as our API grows, it's going to be interesting to see how much extra work the other frameworks require to do things that ServiceStack provides for free. (Or for <a href="https://servicestack.net/pricing">$800 per developer</a>, depending on what you're doing with it.)</p>  <p><a href="http://lh3.googleusercontent.com/-8opeyU6wAEk/VUfjjIqL4SI/AAAAAAAADqw/E00Lv0nmBmM/s1600-h/image%25255B14%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="image" src="http://lh3.googleusercontent.com/-3Xwe5WmcjPQ/VUfjj8RUldI/AAAAAAAADq0/zZs8jSn9SXA/image_thumb%25255B8%25255D.png?imgmax=800" width="587" height="480" /></a></p>  <p>Now, it's important to remember that we're trying to reflect the <strong>conventions and idioms</strong> of our chosen frameworks here. You could, without too much difficulty, implement the request/service/response pattern favoured by ServiceStack on any of the other frameworks, or to get your ServiceStack services to return raw entities instead of mapping them into Response objects - but if you're trying to make framework A behave like framework B, you might as well just switch to framework B and be done with it.</p>  <p>In the next episode, we're going to make <font face="Consolas"><strong>GET /hello</strong></font> return &quot;Hello, World!&quot;, and in the process look at how to define default values for our route parameters in each of our frameworks. Until then, happy hacking!</p>  