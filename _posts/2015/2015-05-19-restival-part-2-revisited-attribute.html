---
layout: post
title: 'Restival Part 2 Revisited: Attribute Routing in WebAPI'
date: '2015-05-19T22:55:00.001+01:00'
author: Dylan Beattie
tags:
- rest
- architecture
- restival
modified_time: '2015-05-19T23:00:07.490+01:00'
thumbnail: http://lh3.googleusercontent.com/-MEUoRkPhEJo/VVuxVk6PbII/AAAAAAAADrg/BjH8BgwMe_U/s72-c/image_thumb%25255B6%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-1220157166841121201
blogger_orig_url: http://www.dylanbeattie.net/2015/05/restival-part-2-revisited-attribute.html
---

<p>(Code for this instalment is <a href="https://github.com/dylanbeattie/Restival/tree/v0.0.3">version 0.0.3 on GitHub</a> if you're following along.)</p>  <p>Mike Thomas commented on my last post, asking &quot;<a href="http://dylanbeattie.blogspot.co.uk/2015/05/restival-part-3-hello-world.html?showComment=1431332366041#c1696253640652788495">any reason why you are not looking at attribute routing in WebAPI</a>&quot;? To which my answer is &quot;yes - I didn't know it existed&quot;, which I'd argue is a pretty good reason why I hadn't looked at it! But Mike's absolutely right to bring it up - if we're comparing frameworks, it makes a lot of sense to really explore the full capabilities of those frameworks. So I've been reading up on attribute routing, and have to say it looks rather nice - and will, I suspect, help out with a lot of the more advanced stuff that's coming up in future instalments. </p>  <p>According to <a href="http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2">the documentation on www.asp.net</a>:</p>  <blockquote>   <p>Web API 2 supports a new type of routing, called <em>attribute routing</em>. As the name implies, attribute routing uses attributes to define routes. Attribute routing gives you more control over the URIs in your web API. For example, you can easily create URIs that describe hierarchies of resources.</p>    <p>The earlier style of routing, called convention-based routing, is still fully supported. In fact, you can combine both techniques in the same project.</p> </blockquote>  <p>Sounds good, right? So what do we need to do to make Restival's WebAPI implementation run on attribute routing instead of convention-based routing?</p>  <p>As it turns out, not much. Well, apart from a little light <a href="http://en.wiktionary.org/wiki/yak_shaving">yak-shaving</a>. Attribute routing is in the Microsoft.AspNet.WebApi.WebHost package - so let's install it:</p>  <blockquote>   <p><font face="Consolas">PM&gt; Install-Package Microsoft.AspNet.WebApi.WebHost       <br />Attempting to resolve dependency 'Microsoft.AspNet.WebApi.Core (≥ 5.2.3 &amp;&amp; &lt; 5.3.0)'.        <br />Attempting to resolve dependency 'Microsoft.AspNet.WebApi.Client (≥ 5.2.3)'.        <br />        <br />...</font></p>    <p><font style="background-color: #ffff00" face="Consolas">Install failed. Rolling back...       <br /></font><font style="background-color: #ff0000" color="#ffffff" face="Consolas">Install-Package : Could not install package 'Microsoft.AspNet.WebApi.Client 5.2.3'. You are trying to install this package        <br />into a project that targets '.NETFramework,Version=v4.0', but the package does not contain any assembly references or content         <br />files that are compatible with that framework. For more information, contact the package author.At line:1 char:1        <br />+ Install-Package Microsoft.AspNet.WebApi.WebHost        <br />+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        <br />&#160;&#160;&#160; + CategoryInfo&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; : NotSpecified: (:) [Install-Package], InvalidOperationException        <br />&#160;&#160;&#160; + FullyQualifiedErrorId : NuGetCmdletUnhandledException,NuGet.PowerShell.Commands.InstallPackageCommand</font></p> </blockquote>  <p>OK, no problem - we're currently targeting .NET 4.0 and it looks like WebApi.WebHost wants .NET 4.5. Right-click, properties, Target Framework to .NET Framework 4.5.1, done. Shift-Ctrl-B... what's this?</p>  <p><a href="http://lh3.googleusercontent.com/-_hngnvnFRQc/VVuxUwHmW9I/AAAAAAAADrc/ADu7PbaKrQM/s1600-h/image%25255B12%25255D.png"><img title="image" style="display: inline" alt="image" src="http://lh3.googleusercontent.com/-MEUoRkPhEJo/VVuxVk6PbII/AAAAAAAADrg/BjH8BgwMe_U/image_thumb%25255B6%25255D.png?imgmax=800" width="934" height="227" /></a></p>  <p>Oh. OK. Let's enable NuGet Package Restore so it'll reinstall packages when we compile the solution... oh dear:</p>  <p><a href="http://lh3.googleusercontent.com/-j3e4PuRK-Fs/VVuxWTeH1fI/AAAAAAAADro/ujooNJfH2AM/s1600-h/image%25255B13%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="image" src="http://lh3.googleusercontent.com/-3cgCIEwiAXo/VVuxW_41j-I/AAAAAAAADr0/OnIGv7xnARc/image_thumb%25255B7%25255D.png?imgmax=800" width="498" height="293" /></a></p>    <p>Oh, joy. Right. This just stopped being fun, because now the solution has entered a sort of weird limbo-state where it's not restoring packages, but the option to enable package restore has disappeared. Time for a tried and tested troubleshooting routine:</p>  <ol>   <li>Close Visual Studio. Completely. SHUT IT DOWN. Yes. And the other instance you've got open. In fact, reboot the machine. DO IT.</li>    <li>Whilst it reboots, get something to drink. Coffee if you're on the clock <font size="1">(did I mention Spotlight has a bean-to-cup espresso machine? We're hiring, you know...) </font>- or <a href="http://metal-and-wine.com/en/">something a little stronger</a> if you're not. </li>    <li>Put on &quot;<a href="https://open.spotify.com/track/0kHQcbHlfUhpDh00G2460e">Turn Up the Radio</a>&quot; by Autograph.</li>    <li>Take a deep breath.</li>    <li>Re-open Visual Studio, re-open your solution, try building it again.</li> </ol>  <p>This time, it builds. It gives a warning about assembly version conflicts, and then settles down to 0 errors and 1 warning:</p>  <blockquote>   <p>Warning: Some NuGet packages were installed using a target framework different from the current target framework and may need to be reinstalled. Visit <a href="http://docs.nuget.org/docs/workflows/reinstalling-packages">http://docs.nuget.org/docs/workflows/reinstalling-packages</a> for more information.&#160; Packages affected: EntityFramework, Microsoft.Net.Http</p> </blockquote>  <p>Well, we're not using Entity Framework so I can just remove it. Except I can't, because Microsoft.AspNet.Providers.Core uses EntityFramework, and Microsoft.AspNet.Providers.LocalDB uses Providers.Core... but since I'm not using ANY of those, we can remove LocalDB, which removes Core, which removes EntityFramework, and we're down to a single warning about Microsoft.Net.Http, which we can fix with a NuGet package reinstall. Simple.</p>  <blockquote>   <p><font face="Consolas"><strong>PM&gt; Update-Package -reinstall Microsoft.Net.Http</strong>        <br />Removing 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.WebApi.        <br />Successfully removed 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.WebApi.        <br />Removing 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.ServiceStack.        <br />Successfully removed 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.ServiceStack.        <br />Removing 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.OpenRasta.        <br />Successfully removed 'Microsoft.Net.Http 2.0.20710.0' from Restival.Api.OpenRasta.        <br />Uninstalling 'Microsoft.Net.Http 2.0.20710.0'.        <br />Successfully uninstalled 'Microsoft.Net.Http 2.0.20710.0'.        <br />Installing 'Microsoft.Net.Http 2.0.20710.0'.        <br />You are downloading Microsoft.Net.Http from Microsoft, the license agreement to which is available at </font><a href="http://www.microsoft.com/web/webpi/eula/MVC_4_eula_ENU.htm"><font face="Consolas">http://www.microsoft.com/web/webpi/eula/MVC_4_eula_ENU.htm</font></a><font face="Consolas">. Check the package for additional dependencies, which may come with their own license agreement(s). Your use of the package and dependencies constitutes your acceptance of their license agreements. If you do not accept the license agreement(s), then delete the relevant components from your device.       <br />Successfully installed 'Microsoft.Net.Http 2.0.20710.0'.        <br />Adding 'Microsoft.Net.Http 2.0.20710.0' to Restival.Api.WebApi.        <br /><font style="background-color: #ffff00">Install failed. Rolling back...         <br /></font><font style="background-color: #ff0000" color="#ffffff">Update-Package : Unable to uninstall 'Microsoft.Net.Http 2.0.20710.0' because 'Microsoft.AspNet.WebApi.OData 4.0.30506'          <br />depends on it.At line:1 char:1          <br />+ Update-Package -reinstall Microsoft.Net.Http          <br />+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          <br />&#160;&#160;&#160; + CategoryInfo&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; : NotSpecified: (:) [Update-Package], Exception          <br />&#160;&#160;&#160; + FullyQualifiedErrorId : NuGetCmdletUnhandledException,NuGet.PowerShell.Commands.UpdatePackageCommand          <br /></font>&#160; <br />'Microsoft.Net.Http 2.0.20710.0' already installed.        <br />Adding 'Microsoft.Net.Http 2.0.20710.0' to Restival.Api.ServiceStack.        <br />Successfully added 'Microsoft.Net.Http 2.0.20710.0' to Restival.Api.ServiceStack.        <br />'Microsoft.Net.Http 2.0.20710.0' already installed.        <br />Adding 'Microsoft.Net.Http 2.0.20710.0' to Restival.Api.OpenRasta.        <br />Successfully added 'Microsoft.Net.Http 2.0.20710.0' to Restival.Api.OpenRasta.</font></p>    <p><font face="Consolas">PM&gt;</font> </p> </blockquote>  <p>Hmm. I don't even know what WebApi.OData is, and I'm pretty sure I'm not using it... Let's remove it. Which, of course, means removing a bunch of other things, including Microsoft.Net.Http... which requires another Visual Studio restart. And this time, Update-Package fails because Microsoft.Net.Http is actually <em>gone</em>... so let's install it:</p>  <blockquote>   <p><strong><font face="Consolas">PM&gt; Install-Package Microsoft.Net.Http</font></strong></p> </blockquote>  <p>Zing! Done. Clean build, zero errors, zero warnings, it works. Now we can actually implement attribute routing.</p>  <p>First, we're going to remove our existing Hello route and enable attribute routing:</p>  <blockquote>   <p><font face="Consolas">public static class WebApiConfig {       <br />&#160;&#160;&#160; public static void Register(HttpConfiguration config) {        <br /><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; config.MapHttpAttributeRoutes();</strong>        <br /></font><font color="#9bbb59" face="Consolas"><font color="#008000">&#160;&#160;&#160;&#160;&#160;&#160;&#160; //config.Routes.MapHttpRoute(         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; &quot;Hello&quot;, // route name          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; &quot;hello/{name}&quot;, // route template          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; new { Controller = &quot;Hello&quot;, Name = &quot;World&quot; } // defaults          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; );</font>        <br />&#160;<font color="#000000">&#160;&#160; }         <br />}</font></font></p> </blockquote>  <p>Next, we need to decorate our HelloController with the route attribute:</p>  <blockquote>   <p><font face="Consolas">public class HelloController : ApiController {       <br /><strong>&#160;&#160;&#160; [Route(&quot;hello/{name}&quot;)]         <br /></strong>&#160;&#160;&#160; public Greeting Get(string name) {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (new Greeting(name));        <br />&#160;&#160;&#160; }        <br />}</font></p> </blockquote>  <p>FInally, we need to change the way we register our configuration, because <a href="http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2#enable">the old WebAPI 1.x convention isn't compatible with attribute routing</a>:</p>  <blockquote>   <p><font face="Consolas">protected void Application_Start() {       <br /><font color="#008000">&#160;&#160;&#160; // Old WebAPI 1.x syntax - not compatible with attribute routing:         <br />&#160;&#160;&#160; // WebApiConfig.Register(GlobalConfiguration.Configuration);          <br />          <br />&#160;&#160;&#160; // New WebAPI 2.x configuration via delegate instead of direct method call</font>        <br /><strong>&#160;&#160;&#160; GlobalConfiguration.Configure(WebApiConfig.Register);         <br /></strong>}</font></p> </blockquote>  <p>That works - well, everything works except our default &quot;Hello, World&quot; scenario - so let's add a default value to the {name} parameter in our route attribute:</p>  <blockquote>   <p><font face="Consolas">public class HelloController : ApiController {       <br />&#160;&#160;&#160; [Route(&quot;hello/{name<font style="background-color: #ffff00"><strong>=World</strong></font>}&quot;)]        <br />&#160;&#160;&#160; public Greeting Get(string name) {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (new Greeting(name));        <br />&#160;&#160;&#160; }        <br />}</font></p> </blockquote>  <p>And there you go. Attribute routing works, all tests are passing - and a yak so impeccably shaved you could use it to sell cologne. Not bad. </p>  