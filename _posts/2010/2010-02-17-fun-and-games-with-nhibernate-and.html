---
layout: post
title: Fun and Games with NHibernate and String Keys
date: '2010-02-17T11:33:00.001Z'
author: Dylan Beattie
tags: 
modified_time: '2010-02-17T12:31:44.606Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-6898183245551702620
blogger_orig_url: http://www.dylanbeattie.net/2010/02/fun-and-games-with-nhibernate-and.html
---

<p>One of the team spent much of yesterday banging his head against the wall. We had a query that took 18ms to run in Query Analyzer, and 1800ms to run from NHibernate. <a href="http://nhprof.com/">NHibernate Profiler</a> would report 1800-2200 ms – and copying’n’pasting the <em>exact same query statement<strong> </strong></em>into Query Analyzer would run it in &lt; 20 ms. Running the same SQL statement via ADO.NET, from the same block of code, proved it wasn’t a network latency issue or anything - ADO.NET came back in 20ms, NHibernate still took over 2 seconds. </p>  <p>Finally, thanks to SQL Profiler, we managed to work out what was going on. The table in question had a primary key which was a varchar(9); in this instance, we were filtering on a particular primary key value – and <strong>NHibernate was specifying the value as an nvarchar(6), </strong> because NHibernate treats strings as unicode (nvarchar) by default. This C# code</p>  <blockquote>   <p>currentSession     <br />&#160;&#160;&#160; .CreateCriteria&lt;UserFeedItem&gt;()      <br />&#160;&#160;&#160; .Add(Expression.Eq(&quot;User.UserCode&quot;, “abc123”)) // is a varchar(9) in the database for historical reasons      <br />&#160;&#160;&#160; .AddOrder(Order.Asc(&quot;Received&quot;))      <br />&#160;&#160;&#160; .SetFirstResult(firstResult)      <br />&#160;&#160;&#160; .SetMaxResults(resultCount)      <br />&#160;&#160;&#160; .List&lt;UserFeedItem&gt;()      <br />); </p> </blockquote>  <p>was resulting in the following SQL statement </p>  <blockquote>   <p>exec sp_executesql      <br />&#160;&#160;&#160; N'SELECT TOP 50 FeedItemId16_0_, FeedUser16_0_, MailSent16_0_, ItemSeen16_0_, Deleted16_0_, Received16_0_       <br />&#160;&#160;&#160; FROM (      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; SELECT this_.FeedItemId as FeedItemId16_0_, this_.FeedUser as FeedUser16_0_, this_.MailSent as MailSent16_0_, this_.ItemSeen as ItemSeen16_0_, this_.Deleted as Deleted16_0_, this_.Received as Received16_0_, ROW_NUMBER() OVER(ORDER BY this_.Received) as __hibernate_sort_row FROM Spotweb.dbo.[FeedUserFeedItem] this_ WHERE this_.FeedUser = @p0) as query WHERE query.__hibernate_sort_row &gt; 50 ORDER BY query.__hibernate_sort_row',      <br />&#160;&#160;&#160; N'@p0 nvarchar(6)',      <br />&#160;&#160;&#160; @p0=N'abc123'</p> </blockquote>  <p>This means SQL Server has to do an implicit conversion when comparing your parameter value to the table’s primary key value – instead of using indexes, it has to retrieve every row, cast the primary key to an nvarchar(6), and then see whether the result is equal to your parameter. As you can imagine, this slows things down a little – especially on a table with several million records.</p>  <p>The immediate solution for this was to rewrite the code as follows:</p>  <blockquote>   <p>currentSession     <br />&#160;&#160;&#160; .CreateQuery(&quot;from UserFeedItem where User.UserCode = :code&quot;)      <br /><strong>&#160;&#160;&#160; .SetParameter(&quot;code&quot;, “abc123”, TypeFactory.GetAnsiStringType(9))</strong>      <br />&#160;&#160;&#160; .SetFirstResult(firstResult)      <br />&#160;&#160;&#160; .SetMaxResults(resultCount)      <br />&#160;&#160;&#160; .List&lt;UserFeedItem&gt;()      <br />);</p> </blockquote>  <p>- notice how on the third line we’re explicitly specifying TypeFactory.GetAnsiStringType(9) to force NHibernate to specify the parameter as a varchar(9). A better solution is to explicitly specify the mapping type for the column – we’re using Fluent NHibernate, so the mapping override code looks like this:</p>  <blockquote>   <p>public class SiteUserOverrides : IAutoMappingOverride&lt;SiteUser&gt; {     <br />&#160;&#160;&#160; public void Override(AutoMapping&lt;SiteUser&gt; map) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; map.Id(u =&gt; u.UserCode).CustomType(“AnsiString”);      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>and now any reference in any query to a SiteUser.UserCode will be properly mapped as varchar instead of nvarchar.</p>  <p>Moral of the story: be careful with varchar and nvarchar keys when using NHibernate; make sure there aren’t implicit type conversions happening all over the place, because they can seriously mess up your performance.</p>  <p>It’s also worth noting that even the excellent NHibernate Profiler couldn’t shed any light on what was going on here – SQL Profiler (included with SQL Server) is still an incredibly powerful and under-used tool, and it’s well worth spending a couple of hours getting to grips with it.</p>  