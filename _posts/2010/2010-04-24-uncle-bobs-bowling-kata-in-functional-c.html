---
layout: post
title: Uncle Bob’s Bowling Kata in Functional C#
date: '2010-04-24T19:20:00.001+01:00'
author: Dylan Beattie
tags:
- dotnet
- c#
modified_time: '2017-03-18T15:03:45.217Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-7081280987761117997
blogger_orig_url: http://www.dylanbeattie.net/2010/04/uncle-bobs-bowling-kata-in-functional-c.html
redirect_from: "/2010/04/uncle-bobs-bowling-kata-in-functional-c.html"

---

<p>During the session on functional programming at <a href="http://openvolcano10.eventbrite.com/">OpenVolcano10</a> this week, <a href="http://www.objectmentor.com/omTeam/martin_r.html">Uncle Bob Martin</a> spoke of a particularly elegant functional solution to his <a href="http://butunclebob.com/ArticleS.UncleBob.TheBowlingGameKata">bowling game kata</a>. Proposed by Stuart Halloway, <a href="http://github.com/stuarthalloway/clojure-bowling">the solution</a> regards the bowling game itself as a (potentially infinite) sequence of ‘rolls’ (balls), and then uses some nicely elegant list manipulation to extract ten valid scoring frames from the sequence of balls and calculate the score of the game.</p>  <p>C# and IEnumerable&lt;T&gt; allow you to do some very similar things in .NET – basically, you can define operations in terms of mapping one infinite list to another infinite list, and you don’t have to worry about stack overflows or out of memory errors because, thanks to the wonder of lazy evaluation, nothing is actually allocated or returned until you start asking for the resulting values.</p>  <p>Take a look at this code snippet:</p>  <blockquote>   <p>static IEnumerable&lt;Int64&gt; Integers {     <br />&#160;&#160;&#160; get {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (var i = 1; true; i++) yield return (i);      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>If you’re thinking “but that’s just an infinite loop!” – you’re partly right. Yes, it’s infinite, but no, it’s not a loop. The magical <strong>yield return</strong> operator there actually breaks the loop, and allows you go to infinity <em>(<a href="http://www.imdb.com/title/tt0114709/">and beyond!</a>)</em> – <strong>one step at a time</strong>. Using the LINQ Take() method, you can easily slice’n’dice this infinite list into useful pieces:</p>  <blockquote>   <p>// Calculate the sum of the first 20 positive integers:     <br />var sum = Integers.Take(20).Sum(); </p>    <p>// Calculate the product of the first 10 positive integers:     <br />var product = Integers.Take(10).Aggregate((a, b) =&gt; (a * b));</p> </blockquote>  <p>By throwing some extensions methods onto Int64, you can use the same approach to filter the list:</p>  <blockquote>   <p>public static class ExtensionMethods {     <br />&#160;&#160;&#160; public static bool IsPrime(this Int64 candidate) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((candidate &amp; 1) == 0) return (candidate == 2);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var num = (int)Math.Sqrt((double)candidate);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (var i = 3; i &lt;= num; i += 2) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((candidate % i) == 0) return false;      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return true;      <br />&#160;&#160;&#160; }      <br />}</p>    <p>// now we’ve defined myInt64.IsPrime(), we can do this:     <br />var primes = Integers.Where(i =&gt; i.IsPrime()); </p> </blockquote>  <p>We now have a C# variable – <strong>primes</strong> – that, for all intents and purposes, contains <strong>all the prime numbers</strong>. If we try to print the entire list, our program will never terminate – but that’s what we’d expect, because the list of prime numbers is infinite. We can, however, do things like printing a list of the first 100 primes:</p>  <blockquote>   <p>foreach(var prime in primes.Take(100)) Console.WriteLine(prime);</p> </blockquote>  <p>or calculating the product of the first 50 primes:</p>  <blockquote>   <p>var product = primes.Take(50).Aggregate((a,b) =&gt; (a*b));</p> </blockquote>  <p>So, what’s all this got to do with bowling? Well – using this approach, we can store the progress of a bowling game as a (potentially infinite?) list of rolls, and by using a couple of useful extension methods on IEnumerable&lt;int&gt;, we can calculate the resulting ten-pin bowling score in a single LINQ statement:</p>  <blockquote>   <p>var score = rolls.ToFrames().Take(10).Sum(frame =&gt; frame.Sum());</p> </blockquote>  <p>Here’s the supporting extension methods&#160; - which basically capture the scoring quirks of spares, strikes, frames and the other idiosyncracies of ten-pin-bowling. The ToFrames() method is particularly interesting – it’s translated from the <strong>cons </strong>operator in Lisp/Clojure, and effectively returns a list (the rolls that count towards the current frame), followed by a list of lists (where each list represents a subsequent frame in the game):</p>  <blockquote>   <p>public static class BowlingRules {     <br />&#160;&#160;&#160; public static IEnumerable&lt;IEnumerable&lt;int&gt;&gt; ToFrames(this IEnumerable&lt;int&gt; rolls) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield return (rolls.Take(rolls.BallsToScore()));      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach(var frame in (rolls.Skip(rolls.FrameAdvance()).ToFrames())) {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield return(frame);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private static int FrameAdvance(this IEnumerable&lt;int&gt; rolls) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (rolls.IsStrike() ? 1 : 2);      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private static int BallsToScore(this IEnumerable&lt;int&gt; rolls) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (rolls.IsBonus() ? 3 : 2);      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private static bool IsStrike(this IEnumerable&lt;int&gt; rolls) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (rolls.Take(1).Sum().Equals(10));      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private static bool IsSpare(this IEnumerable&lt;int&gt; rolls) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (rolls.Take(2).Sum().Equals(10));      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private static bool IsBonus(this IEnumerable&lt;int&gt; rolls) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (rolls.IsSpare() || rolls.IsStrike());      <br />&#160;&#160;&#160; }      <br />} </p> </blockquote>  <p>The project – including the unit test from Uncle Bob’s kata translated to NUnit / C# – is up on <a href="http://code.google.com/p/dylanhax/source/browse/#svn/trunk/BowlingKata/BowlingKata.Game">Google Code</a> if you want to take a look. </p>  