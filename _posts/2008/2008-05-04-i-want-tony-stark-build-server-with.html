---
layout: post
title: I Want Tony Stark's Build Server (with possible "Iron Man" Spoilers...)
date: '2008-05-04T00:59:00.001+01:00'
author: Dylan Beattie
tags:
- movies
- codegen
- random
modified_time: '2008-05-06T22:42:17.327+01:00'
thumbnail: http://lh4.ggpht.com/dmb197/SBz8Rvvt-WI/AAAAAAAAADM/WTt3wFnxPL0/s72-c/hr_Iron_Man_22_thumb.jpg
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-5694683300520568203
blogger_orig_url: http://www.dylanbeattie.net/2008/05/i-want-tony-stark-build-server-with.html
---

<p>Personally, I think the ideal software development process boils down to three things:</p>  <p><strong>1. Every decision is reflected in exactly one place in your project. </strong></p>  <p>By this, I don't necessarily mean documented. Documentation is there to <em>direct</em> the people who are implementing the decisions, and to <em>explain</em> the business context and background information that's necessary to understand the actual code/schema/designs/whatever. I mean that, if a customer's name is limited to 32 characters, you type that number 32 <em>exactly once</em> in your entire project, and everything that needs to know how long a customer name can be refers to that one place where you originally recorded it.</p>  <p><strong>2. Your tools allow each decision to be expressed clearly, succintly and quickly</strong></p>  <p>Most of the worthwhile progress I've seen with software development is about letting the developer express their intent quickly and without ambiguity. String code in C is basically arithmetic manipulation of arrays of numbers. String code in .NET or Ruby is a whole lot friendlier; there's a compile and runtime overhead, but Moore's Law is on our side and, with a few exceptions, I think speed of development and ease of maintenance are becoming more important than speed of execution for most software these days.&#160; </p>  <p><strong>3. Everything else is generated automatically.</strong></p>  <p>If I change my mind about something, I don't want to have to tell a whole bunch of classes that I've changed my mind. I don't believe it's possible to build software without making some assumptions - even if I have a signed-off set of requirements, I'm still assuming that the person who signed the requirements understood what the client actually <em>wants</em> - and when these assumptions turn out to be wrong, I want to be able to correct them quickly and painlessly. </p>  <p>I have a homebrewed code-generation system based on <a href="http://www.codesmithtools.com/" target="_blank">CodeSmith</a> that will generate a pretty comprehensive set of domain model objects and supporting DAL and stored procedures based on a SQL Server database. If we decide that a customer's name is compulsory and is limited to 32 characters, I change the Name column in the Customer table in our DB to a varchar(32) NOT NULL, and re-generate the code. 30 seconds later, my Customer class includes validation rules that check that Customer.Name is not null, not empty, and no greater than 32 characters - and throw a descriptive exception &quot;Sorry, Customer.Name is limited to 32 characters&quot; if you exceed the limit. The generated objects implement the <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.idataerrorinfo.aspx" target="_blank">IDataErrorInfo interface</a> for automatic validation of data-bound WinForms apps, and use a variation on the MVP pattern that means that for each business object, we also generate an interface defining that object's editable fields - so you make your CustomerEditForm.ascx.cs code-behind class implement ICustomerView, and you can validate by calling Customer.ValidateView(this, &quot;Name&quot;) from your user controls and get a nice (and completely auto-generated) error message if there's anything wrong with the name you've just entered.</p>  <p>That example is from Real Life. That's why it's a bit... technical.</p>  <p>[Potential spoilers after the photo... careful now.]</p>  <p>&#160;</p>  <p style="text-align: center"><a href="http://lh6.ggpht.com/dmb197/SCDQtPvt-XI/AAAAAAAAADE/XPR0lkdLZ2s/hr_Iron_Man_22%5B1%5D.jpg"><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="324" alt="Tony Stark working on his Iron Man suit (Copyright &#169; Marvel / Paramount)" src="http://lh4.ggpht.com/dmb197/SBz8Rvvt-WI/AAAAAAAAADM/WTt3wFnxPL0/hr_Iron_Man_22_thumb.jpg" width="484" border="0" /></a></p>  <p>&#160;</p>  <p>Driving home from watching <a href="http://www.imdb.com/title/tt0371746/" target="_blank">Iron Man</a> tonight, it occurred to me... in the movie, they do basically the same thing, but they do it with <em>style</em>. There's a scene about halfway through Iron Man where Tony Stark, our intrepid millionaire-playboy-genius-weapons-designer-turned-superhero, is putting the finishing touches on his Iron Man suit in his Malibu beachfront workshop. (I told you fiction made it look cool.) His computer system - known as 'Jarvis', apparently - brings up a 3D visualisation of his latest design; Tony casually asks Jarvis to &quot;throw a little hot-rod red in there&quot;, and then goes off to drink scotch and dance with <a href="http://images.google.com/images?q=gwyneth+paltrow" target="_blank">Gwyneth Paltrow</a> while the system does the actual suit fabrication.</p>  <p>Ok, so I'm assuming there's some A.I. involved and that a certain visual style is implied by the phrase &quot;hot-rod red&quot; - but that's just about configuring your tools to suit your preference. Otherwise, it's just a really powerful configuration and build server... you make a decision, you record it <em>once</em>, and the system does the rest while you go dancing. Oh, and there's also the fact that it makes experimental rocket-powered bulletproof flying superhero suits instead of database-driven websites... but we can work on the details later, right? </p>  <p>Anyway. Point is - next time I have to explaining code generation and continuous integration to a non-developer, I'll start by asking if they saw Iron Man, and we'll take it from there.</p>  