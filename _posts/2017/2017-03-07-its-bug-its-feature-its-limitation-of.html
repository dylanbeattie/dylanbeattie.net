---
layout: post
title: It's a bug! It's a feature! It's… a limitation of the fundamental design of
  your test framework?
date: '2017-03-07T14:26:00.000Z'
author: Dylan Beattie
tags:
- c#
modified_time: '2017-03-18T14:48:07.566Z'
thumbnail: https://lh3.googleusercontent.com/-gph4CxYGtvI/WMLP8uGjZ6I/AAAAAAAAEVs/pOOoygNV2HA/s72-c/image_thumb%25255B11%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-7038972586186166320
blogger_orig_url: http://www.dylanbeattie.net/2017/03/its-bug-its-feature-its-limitation-of.html
---

<p>As some of you probably know, I'm a big fan of <a href="http://www.ncrunch.net/">NCrunch</a>. When I'm coding in C#, NCrunch gets a CPU core and a whole screen to itself (yes, I don't really write code on a system that <a href="https://twitter.com/dylanbeattie/status/832326857798348800/photo/1">looks like this</a>) and sits there quietly running all my tests, all the time, and telling me the second I break anything.</p> <p>I'm also a big fan of testing things that are as close to production behaviour as you can. Unit tests are great for informing the design of your components, but without integration testing you can't be sure they're actually going to work when you stick them together.</p> <blockquote class="twitter-tweet" data-lang="en" data-conversation="none"> <p lang="und" dir="ltr"><a href="https://twitter.com/ThePracticalDev">@ThePracticalDev</a> <a href="https://twitter.com/testobsessed">@testobsessed</a> <a href="https://t.co/uKvhzoEPF7">pic.twitter.com/uKvhzoEPF7</a></p>— George Dinwiddie (@gdinwiddie) <a href="https://twitter.com/gdinwiddie/status/690726656449839104">January 23, 2016</a></blockquote> <p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>So on my current project, there's a suite of unit tests using FakeItEasy and assertions, and then a suite of integration tests that connect to the live API, follow the various hypermedia links, throw assorted JSON objects at the PUT and POST endpoints to see how they respond, and then call DELETE to clean up when they're done. And, just to keep us honest, we've got a post-deploy step in our Octopus Deploy script that will actually run the integration test suite as part of the deployment process, and roll the whole thing back if any of the tests fail. Another small step on the road to truly continuous deployment. </p> <p>Anyway. Last week, I push a release to our dev environment, and a whole load of tests fail. Which is weird, because it worked on MY machine. And it worked on my machine when I pointed my local codebase at the database in the dev environment. And – here's the fun part – it worked on my machine when I pointed the <em>entire test suite </em>at the dev environment. So I start eliminating variables. One of the first things I pick up on is that my local test runner is NCrunch, whereas the post-deploy step is using nunit-console. So I run the local integration tests using nunit-console and – bang. Failures. Which is good, because I know what's causing the weirdness, but <em>weird</em>, because tests are supposed to either pass or fail regardless of what test runner you're using.</p> <p>So I dig a little deeper, and I end up with what looks to me like a bug in NCrunch. See, we're using the TestCaseSource attribute to generate test cases for the API tests, and – because all we need is a bunch of different JSON objects – we're just spinning up new anonymous objects and passing them in as test cases.</p> <p>Here's two anonymous objects:</p><pre><code>var testCase1 = new { forenames = null, surname = "Batman" }<br>var testCase2 = new { forenames = String.Empty, surname = "Batman" }
</code></pre>
<p>What I noticed is that if you generate these two test cases, NCrunch will only see them as a single test – which I assumed was because their ToString() representations are equal, because null and String.Empty both return String.Empty when you ToString() them in this situation. So I opened a post about it on the <a href="http://forum.ncrunch.net/yaf_postst2060_NCrunch-is-ignoring-TestCaseSource-cases-where-the-test-case-ToString---is-non-unique.aspx">NCrunch forums</a>, even going so far as to suggest using GetHashCode() when enumerating test names, and got <a href="http://forum.ncrunch.net/yaf_postsm9876_NCrunch-is-ignoring-TestCaseSource-cases-where-the-test-case-ToString---is-non-unique.aspx#post9876">this really interesting response</a> from <a href="https://twitter.com/remcomulder?lang=en">Remco Mulder</a>, the NCrunch lead developer:</p>
<blockquote>
<p><em>Tests must be uniquely identifiable between execution and discovery runs. This isn't important for a tool like the nunit console runner where a test can be discovered and executed within the same process call (and thus identified by its memory address), but for a tool like NCrunch, there's no way to run the test or collect data from it without this. As you've identified, generated tests with a null parameter and an empty string will return the same result under .ToString(), so NCrunch can't tell them apart. </em></p>
<p><em>The only way to solve this is to change the design of your code. Try using the NUnit .SetName() method to give each of your generated tests a distinctive name.</em></p>
<p><em>Unfortunately .GetHashCode() is not a reliable solution to this problem as this method is not designed to generate the same identifier across different processes. This method returns different results under x86 vs x64, and under .NET Core it will actually return an entirely different result for each process. Because your code is responsible for generating the tests, the problem can only be solved within your own code.</em></p></blockquote>
<p>I thought this was a really interesting insight into how a tool like NCrunch has to deal with situations that an in-process test runner like nunit-console will probably never encounter. It also turns out I’d dismissed that very warning a few weeks earlier – when it cropped up in response to an unrelated issue which produced the same symptons – and sure enough, after clicking the “Show all hidden warnings” button on the NCrunch toolbar, the warning popped back up – along with a very detailed explanation of what was causing it:</p>
<p><a href="https://lh3.googleusercontent.com/-AfkuRzT19Ls/WMLP8ECTHdI/AAAAAAAAEVo/SC5qALGtC8s/s1600-h/image%25255B19%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://lh3.googleusercontent.com/-gph4CxYGtvI/WMLP8uGjZ6I/AAAAAAAAEVs/pOOoygNV2HA/image_thumb%25255B11%25255D.png?imgmax=800" width="675" height="736"></a></p>
<p>Plus, I had no idea that NUnit has a <a href="http://TestCaseData">TestCaseData</a> interface with a SetName() method on it, which gives a much nicer way of presenting these test cases in both NCrunch and NUnit. I've ended up with something akin to:</p><pre><code>public static IEnumerable TestData() {
  foreach (var data in new[] { null, String.Empty }) {
    var testCase = new { forenames = data, surname = "Batman" };
    var json = JsonConvert.SerializeObject(testCase);
    yield return new TestCaseData(testCase).SetName(json);
  }
}</code></pre>
<p>Oh, and if you're interested, the deployment failures were because of a weird validation rule that treats <strong>null</strong> as missing, which is fine, but String.Empty as an empty string which violates a string length constraint. Which is wrong, and now the API doesn't do it any more. This is just another reason why integration testing is a good idea. So there you have it – a bug that wasn’t a bug, a crash-course in how NUnit and NCrunch actually work behind the scenes, and a TIL for naming your NUnit tests explicitly. Happy Friday.</p>