---
layout: post
title: Semantic Versioning with Powershell, TeamCity and GitHub
date: '2017-01-26T11:46:00.007Z'
author: Dylan Beattie
tags: 
modified_time: '2017-01-26T12:50:23.236Z'
thumbnail: https://lh3.googleusercontent.com/-6k5o1V3-208/WInwjoZ4aPI/AAAAAAAAETM/SS5zrii8saM/s72-c/semantic%252520merging%252520500px_thumb.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-3633726307766508314
blogger_orig_url: http://www.dylanbeattie.net/2017/01/semantic-versioning-with-powershell_26.html
---

<p>Here at <a href="https://www.spotlight.com/">Spotlight Towers</a>, we’ve been using TeamCity as our main build server since version 6; it’s a fantastic tool and we love it dearly. It got even better a few years back when we paired it with the marvellous <a href="https://octopus.com/">Octopus Deploy</a>; TeamCity builds the code and creates a set of deployable packages known as Octopacks; Octopus deploys the packages, and everything works quite nicely. Well, almost everything. One of the few problems that TeamCity + Octopus doesn’t magically solve for us is versioning. In this post, we’re going to look at how we use Git and TeamCity to manage versioning for our individual packages.</p> <p style="border-top: #4488bb 2px solid; border-right: #4488bb 2px solid; border-bottom: #4488bb 2px solid; font-weight: bold; padding-bottom: 8px; padding-top: 8px; padding-left: 8px; border-left: #4488bb 2px solid; padding-right: 8px; background-color: #eeeeff" align="center">If this sounds like your sort of thing, why not come and work for us? That’s right – Spotlight is hiring! We're looking for developers, testers and a new UX/Web designer - check out <a href="https://jobs.spotlight.com/">jobs.spotlight.com</a> and get in touch if you’re interested.</p> <p>First, let’s establish some principles</p> <ul> <li>We are going to respect the semantic versioning convention of MAJOR.MINOR.PATCH, as described at <a href="http://semver.org/">semver.org</a>.  <li>Major and minor versions will be incremented manually. We trust developers to know whether their latest commit should be a new major or minor release according to semantic versioning principles.  <li>Building the same codebase from the same branch twice should produce the same semantic version number.  <li>Packages created from the <strong>master</strong> branch are release packages.  <li>Packages created from a merge head of an open pull request are pre-release packages.  <li>Pre-release packages will use the version number that would be assigned if that branch was accepted for release at build time.</li></ul> <p>Now, here’s the part where we’re going to deviate from the semantic versioning specification, because our packages actually use a four-part version number. We want to include a <strong>build</strong> number in our package versions, but the official semver extension for doing this – MAJOR.MINOR.PATCH<strong>+BUILD</strong> - won’t work with NuGet, so we’re going to use a four-part version number MAJOR.MINOR.PATCH.BUILD. Pre-release packages will be appended with a suffix describing which branch they were built from – MAJOR.MINOR.PATCH.BUILD-BRANCH.</p> <p>OK, here’s an illustrated example that demonstrates what we’re trying to achieve. Master branch is green. Two developers are working on feature branches – blue and red in this example. To create our pre-release builds, we’re using a little-documented but incredibly useful feature of GitHub known as ‘merge heads’. The idea is that if you have an open pull request, the merge head will give you a snapshot of the codebase that <strong>would be created by merging the open pull request into master</strong> – so you’re not just testing your new feature in isolation, you’re actually building and testing your new feature <strong>plus the current state of the master branch</strong>. There is one caveat to this, which I’ll explain below. </p> <p>So, we’ve got TeamCity set up to build and publish packages every time there’s a commit to master or to the merge head of an open pull request, and we’re also occasionally triggering manual builds just to make sure everything’s hanging together properly. Here’s what happens:&nbsp; </p> <p><a href="https://lh3.googleusercontent.com/-LNOyZ0Oif5I/WInwgperRnI/AAAAAAAAETE/YAIUfUoQysQ/s1600-h/semantic%252520merging%252520500px.png"><img title="semantic merging 500px" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="semantic merging 500px" src="https://lh3.googleusercontent.com/-6k5o1V3-208/WInwjoZ4aPI/AAAAAAAAETM/SS5zrii8saM/semantic%252520merging%252520500px_thumb.png?imgmax=800" width="469" height="766"></a></p> <p>That line there that’s highlighted in yellow is a gotcha. At this point in our workflow, we’ve merged PR1 into our master branch, but because we haven’t pushed anything to the blue branch since this happened, the blue merge head is out of date. PR2 does NOT reflect the latest changes to master, and if we trigger a build manually, we’ll end up with a package that doesn’t actually reflect the latest state of the codebase. The workaround is pretty simple; if you’re creating pre-release builds from merge heads, never run these builds manually; make sure you always trigger the build by pushing a change to the branch.</p> <p>Now let’s look at how can we get TeamCity to automatically calculate those semantic version numbers whenever a build is triggered. We’ll start with the major and minor version. We’re going to track these by creating a <strong>version.txt </strong>file in the root of the project codebase, which just contains the major and minor version numbers. If a developer decides that their feature branch represents a new major or minor version, it’s their responsibility to edit <strong>version.txt </strong>as part of implementing the feature. This also means that prerelease packages built from that branch will reflect the new version number whilst master branches will continue to use the old version until the branch gets merged, which I think is rather elegant.</p> <p>For the patch version, we’re going to assume that every commit or merge to the master branch represents a new patch version, according to the following algorithm</p> <ul> <li>If the current version.txt represents a NEW major/minor version, the patch number is zero  <li>Otherwise, the patch number is the patch number of the latest release, incremented by the number of commits to the master branch since that release.</li></ul> <p>So – how do we know how many commits there have been since the last release? First, each time we build a release branch, we’re going to use Git tags to tag the repository with the version number we’ve just built. TeamCity will do this for you automatically using a <strong>build feature</strong> called “VCS labeling”:</p> <p><a href="https://lh3.googleusercontent.com/-_pkE-xNbrns/WIih7yVi5AI/AAAAAAAAERU/wUgz7UCt7XY/s1600-h/image%25255B6%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="https://lh3.googleusercontent.com/-Nzy9Kjh4iRk/WIih8fsn3xI/AAAAAAAAERY/eRD8QtpQJ6o/image_thumb%25255B4%25255D.png?imgmax=800" width="550" height="150"></a></p> <p>Assuming every release has a corresponding tag, now we need to find the most recent release number, which we can do from the Git command line. </p> <blockquote> <p><font face="Consolas">git fetch –tags<br>git tag –sort=v:refname</font></p></blockquote> <p>Git tags aren’t retrieved by default, so we need to explicitly fetch them before listing them. Then we list all the tags, specifying <a href="https://git-scm.com/docs/git-tag">sort=v:refname</a> which causes tag names to be treated as semantic versions when sorting. (Remember that semver sorting isn’t alphanumeric – in alphanumerics, v9 is higher than v12). Once we’ve got the latest tag, we need to count the number of revisions since that tag was created, which we can do using this syntax:</p> <blockquote> <p><font face="Consolas">git rev-list v1.2.3..HEAD –count</font></p></blockquote><font face="Consolas"></font> <p>To use this in our TeamCity build, we'll need to output the various different formats of that version so that TeamCity can use them. We want to do three things here:</p> <ul> <li>Label the VCS root with the three-part semantic version number v1.2.3  <li>Update the AssemblyInfo.cs files with the four-part version number 1.2.3.456 – note that we can’t put any prerelease suffix in the AssemblyInfo version.  <li>Pass the full version – 1.2.3.456-pr789 – to Octopack when creating our deployable packages with Octopus.</li></ul> <p>I've wrapped the whole thing up in a Powershell script which runs as part of the TeamCity build process, which is on GitHub:</p><script src="https://gist.github.com/dylanbeattie/3a2fe5abca14600efee1c88009afc0f8.js"></script> <p>To use it in your project, add versions.ps1 to the root of your project repo; create a text file called version.txt which contains your major.minor version, and then add a TeamCity build step at the beginning of your build process that looks like this:</p> <p><a href="https://lh3.googleusercontent.com/-40opaGiyYLg/WIns840T6VI/AAAAAAAAES0/XmfHbGEPrC0/s1600-h/image%25255B7%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; border-top-width: 0px; margin-right: auto" border="0" alt="image" src="https://lh3.googleusercontent.com/-P_t6m_IFQ0g/WIns9POJU_I/AAAAAAAAES4/IxDcMnFhNYk/image_thumb%25255B4%25255D.png?imgmax=800" width="520" height="579"></a></p> <p>Finally, it’s worth mentioning that to use command-line git from Powershell, I had to set up TeamCity to use an SSH VCS root rather than HTTP, and install the appropriate SSH keys on the TeamCity build agent. I don't know whether this is a genuine requirement or a quirk of our configuration; your mileage may vary. And I still find Powershell infuriatingly idiosyncratic, but hey - you probably knew that already. :)</p> <p>Happy versioning! And like I said, if this sort of thing sounds like something you’d like to work on, awesome - we’re hiring! Check out <a href="https://jobs.spotlight.com/">jobs.spotlight.com</a> for more details and get in touch if you’re interested.</p>