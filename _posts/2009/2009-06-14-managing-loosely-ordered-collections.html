---
layout: post
title: 'Managing Loosely-Ordered Collections : Lopsided Fun with NHibernate'
date: '2009-06-14T23:34:00.001+01:00'
author: Dylan Beattie
tags:
- nhibernate
- dotnet
- altnet
- c#
- coding
- sql
modified_time: '2017-03-18T15:03:45.267Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-981976760805865025
blogger_orig_url: http://www.dylanbeattie.net/2009/06/managing-loosely-ordered-collections.html
redirect_from: "/2009/06/managing-loosely-ordered-collections.html"

---

<p>NHibernate’s <a href="https://www.hibernate.org/hib_docs/nhibernate/1.2/reference/en/html/collections.html#collections-onetomany">One-To-Many</a> mapping allows you to map database one-to-many relationships into various kinds of .NET collections, but I recently hit a bit of a snag regarding the ordering of the collections. For example, consider a simple content management system for a music store’s website. This table:</p>  <table border="1" cellspacing="0" cellpadding="4" width="430"><tbody>     <tr>       <th valign="top" width="93">Id</td> </th>        <th valign="top" width="138">Name</td> </th>        <th valign="top" width="107">ParentPageId</td> </th>        <th valign="top" width="90">Position</td> </tr></th>     </tr>      <tr>       <td valign="top" width="89">1</td>        <td valign="top" width="134">Home</td>        <td valign="top" width="113">null</td>        <td valign="top" width="92">0</td>     </tr>      <tr>       <td valign="top" width="87">2</td>        <td valign="top" width="132">Products</td>        <td valign="top" width="117">1</td>        <td valign="top" width="93">0</td>     </tr>      <tr>       <td valign="top" width="85">3</td>        <td valign="top" width="131">Guitars</td>        <td valign="top" width="120">2</td>        <td valign="top" width="93">0</td>     </tr>      <tr>       <td valign="top" width="84">4</td>        <td valign="top" width="130">Basses</td>        <td valign="top" width="122">2</td>        <td valign="top" width="93">1</td>     </tr>      <tr>       <td valign="top" width="84">5</td>        <td valign="top" width="129">Keyboards</td>        <td valign="top" width="123">2</td>        <td valign="top" width="93">3</td>     </tr>      <tr>       <td valign="top" width="84">6</td>        <td valign="top" width="129">Drums</td>        <td valign="top" width="124">2</td>        <td valign="top" width="93">4</td>     </tr>      <tr>       <td valign="top" width="84">7</td>        <td valign="top" width="129">Services</td>        <td valign="top" width="124">1</td>        <td valign="top" width="93">0</td>     </tr>      <tr>       <td valign="top" width="84">8</td>        <td valign="top" width="129">Guitar Tuition</td>        <td valign="top" width="124">7</td>        <td valign="top" width="93">0</td>     </tr>      <tr>       <td valign="top" width="84">9</td>        <td valign="top" width="129">Guitar Repairs</td>        <td valign="top" width="125">7</td>        <td valign="top" width="93">1</td>     </tr>   </tbody></table>  <p>represents a simple page-tree structure that looks like this:</p>  <blockquote>   <p><strong>Home        <br />&#160;&#160;&#160; +&#160; Products         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Guitars         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Basses         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Keyboards         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Drums         <br />&#160;&#160;&#160; + Services         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Guitar Tuition         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; + Guitar Repairs</strong></p> </blockquote>  <p>The key here is that the <strong>order of the elements is controlled by the Position column, </strong>so I can change the order of any page’s child pages. NHibernate can cope with this just fine by using an indexed collection – but this only works <strong>as long as the Position column is always populated with unique, sequential, non-null values. </strong>Null Position values cause it to blow up. It’ll also leave gaps in the list if there’s gaps in your sequence – five records with Position values 1,2,4,5,8 will be mapped into a nine-element list with NULL entries at indices 0,3,6,7, which turns your foreach() loops into little baby minefields and requires liberal use of guard clauses.</p>  <p>That’s not quite what I’m after here. All I want to do is <strong>preserve the order of elements if an order has been defined</strong>. There’s other apps talking to this database that aren’t using NH, which respect ordering by Position when retrieving records but don’t necessarily use sequential zero-based indices when saving changes. The actual data I’m dealing with is often going to look more like this:</p>  <table border="1" cellspacing="0" cellpadding="4" width="430"><tbody>     <tr>       <th valign="top" width="93">Id</td> </th>        <th valign="top" width="138">Name</td> </th>        <th valign="top" width="107">ParentPageId</td> </th>        <th valign="top" width="90">Position</td> </tr></th>     </tr>      <tr>       <td valign="top" width="89">1</td>        <td valign="top" width="134">Home</td>        <td valign="top" width="113">null</td>        <td valign="top" width="92">0</td>     </tr>      <tr>       <td valign="top" width="87">2</td>        <td valign="top" width="132">Products</td>        <td valign="top" width="117">1</td>        <td valign="top" width="93">0</td>     </tr>      <tr>       <td valign="top" width="85">3</td>        <td valign="top" width="131">Guitars</td>        <td valign="top" width="120">2</td>        <td valign="top" width="93">2</td>     </tr>      <tr>       <td valign="top" width="84">4</td>        <td valign="top" width="130">Basses</td>        <td valign="top" width="122">2</td>        <td valign="top" width="93">null</td>     </tr>      <tr>       <td valign="top" width="84">5</td>        <td valign="top" width="129">Keyboards</td>        <td valign="top" width="123">2</td>        <td valign="top" width="93">5</td>     </tr>      <tr>       <td valign="top" width="84">6</td>        <td valign="top" width="129">Drums</td>        <td valign="top" width="124">2</td>        <td valign="top" width="93">6</td>     </tr>      <tr>       <td valign="top" width="84">7</td>        <td valign="top" width="129">Services</td>        <td valign="top" width="124">1</td>        <td valign="top" width="93">7</td>     </tr>      <tr>       <td valign="top" width="84">8</td>        <td valign="top" width="129">Guitar Tuition</td>        <td valign="top" width="124">7</td>        <td valign="top" width="93">null</td>     </tr>      <tr>       <td valign="top" width="84">9</td>        <td valign="top" width="129">Guitar Repairs</td>        <td valign="top" width="125">7</td>        <td valign="top" width="93">4</td>     </tr>   </tbody></table>  <p>All I’m after is that when I retrieve elements, they are ordered by the Position column (using whatever ORDER BY semantics are in use on the database server), and that if I move things around in the list and then save it, the order of my list is preserved when saving. I don’t care about null values – if there’s no explicit positions defined, just stick whatever you’ve got in a list in any old order and give it back to me. Likewise duplicate values are OK, and if there’s missing values, don’t give me NULLs, just skip to the next element.</p>  <p>One possible solution I’ve come up with looks like this. First, define a Position property on the entity. The getter returns the item’s current index in the parent’s children collection; and the setter is private and does nothing (but NHibernate won’t let you leave it out)</p>  <blockquote>   <p>public virtual int Position {      <br />&#160;&#160;&#160; // Getter returns the current index of this element in its parent's children collection.       <br />&#160;&#160;&#160; get {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (this.Parent == null) return (0);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (this.Parent.Children == null) return (0);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (this.Parent.Children.IndexOf(this));       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; // Setter does nothing - order is determined by the &quot;order-by&quot; attribute in NHibernate mappings,       <br />&#160;&#160;&#160; // but NH requires that the setter exists.       <br />&#160;&#160;&#160; private set { }       <br />}</p> </blockquote>  <p>Then there’s the actual mapping. We want to map this Position property to a DB column, so when doing insert/update operations, the value is persisted to the Position column, and we want to add an order-by attribute to the NHibernate mapping so that when we retrieve the collection, it comes back in the right order. If you’re using the lovely functional goodness that is <a href="http://fluentnhibernate.org/">Fluent NHibernate</a>, the mapping looks like this:</p>  <blockquote>   <p>public class CmsPageMap : ClassMap&lt;CmsPage&gt; {      <br />&#160;&#160;&#160; public CmsPageMap() {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Map(page =&gt; page.Position);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; HasMany&lt;CmsPage&gt;(p =&gt; p.Children)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .KeyColumnNames.Add(&quot;ParentPageId&quot;)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .WithForeignKeyConstraintName(&quot;Page_Parent_Children&quot;)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Inverse()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Cascade.AllDeleteOrphan()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Using SetAttribute() here because Fluent NHibernate doesn't support order-by yet.       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .SetAttribute(&quot;order-by&quot;, &quot;Position&quot;);</p> </blockquote>  <p>and if you’re mapping it using XML files, you’ll need something like this:</p>  <blockquote>   <p>&lt;property name=&quot;Position&quot; type=&quot;Int32&quot;&gt;      <br />&#160; &lt;column name=&quot;Position&quot; /&gt;       <br />&lt;/property&gt;       <br />&lt;many-to-one name=&quot;Parent&quot; column=&quot;ParentPageId&quot; /&gt;       <br />&lt;bag name=&quot;Children&quot; inverse=&quot;true&quot; cascade=&quot;all-delete-orphan&quot; order-by=&quot;Position&quot;&gt;       <br />&#160; &lt;key foreign-key=&quot;Page_Parent_Children&quot; column=&quot;ParentPageId&quot; /&gt;       <br />&#160; &lt;one-to-many class=&quot;NinjaCms.Shared.Model.CmsPage, NinjaCms.Shared&quot; /&gt;       <br />&lt;/bag&gt;</p> </blockquote>  <p>The asymmetry of having a property that’s an order-by on the way out and a column mapping on the way back is slightly weird, but it works.</p>  