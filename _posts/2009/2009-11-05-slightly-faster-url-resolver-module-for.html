---
layout: post
title: A (Slightly Faster) URL Resolver Module for ASP.NET MVC
date: '2009-11-05T00:57:00.001Z'
author: Dylan Beattie
tags:
- dotnet
- c#
modified_time: '2017-03-18T15:03:45.133Z'
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-2174372977090070905
blogger_orig_url: http://www.dylanbeattie.net/2009/11/slightly-faster-url-resolver-module-for.html
---

<p>Yesterday, I posted some code I’d hacked together as part of an MVC2 demo that would resolve ASP.NET virtual path URLs on the fly as pages were written to the ASP.NET response stream.</p>  <p>Having run some tests on this code in isolation – it’s actually quite nasty. For running ad-hoc demos on your workstation, it’s fine, but the performance hit of decoding the byte array, doing the regex transform and re-encoding it is something like <strong>two hundred times</strong> slower than a direct stream copy. Not good. There is now a modified version <a href="http://code.google.com/p/tagalong/source/browse/trunk/DylanHax/Web/UrlResolverModule.cs">online at Google Code</a> which is quite a bit faster, but there’s still huge scope for improvement. In particular, although it’s using byte comparisons now to work out where the <strong>~/ </strong>combination occurs, it’s still falling back to string comparisons every time it finds a tilde to decide whether that tilde needs replacing or not.</p>  <p>These stats were created using a loop that spins up HTML pages of various sizes – one version full of ASP.NET-style tilde paths, one containing no tildes -&#160; and then writes them 100 times to both a normal MemoryStream and a UrlResolverStream in order to calculate the average rendering time. If a page doesn’t contain any tildes at all, performance is 5-6 times slower than the equivalent direct memory copy – i.e. 21ms instead of 4ms. For pages with <em>lots</em> of tildes, the additional string processing hits quite hard and you’re looking at a slowdown factor of around 30-35x. </p>  <table border="1" cellspacing="0" cellpadding="4" width="640"><tbody>     <tr>       <td width="81"><strong>Tildes?</strong></td>        <td width="80"><strong>Page Size</strong></td>        <td width="184"><strong>MemoryStream copy (ms)</strong></td>        <td width="204"><strong>UrlResolverStream copy (ms)</strong></td>        <td width="89"><strong>Ratio</strong></td>     </tr>      <tr>       <td width="84">Yes</td>        <td width="84">50Kb</td>        <td width="182">0.05</td>        <td width="203">0.38</td>        <td width="88">7</td>     </tr>      <tr>       <td width="86">Yes</td>        <td width="87">101Kb</td>        <td width="181">0.17</td>        <td width="202">2.51</td>        <td width="87">14</td>     </tr>      <tr>       <td width="87">Yes</td>        <td width="89">202Kb</td>        <td width="180">0.19</td>        <td width="201">6.05</td>        <td width="87">31</td>     </tr>      <tr>       <td width="87">Yes</td>        <td width="90">405Kb</td>        <td width="180">0.37</td>        <td width="201">13.88</td>        <td width="87">37</td>     </tr>      <tr>       <td width="87">Yes</td>        <td width="91">809Kb</td>        <td width="180">0.88</td>        <td width="200">29.47</td>        <td width="87">33</td>     </tr>      <tr>       <td width="87">Yes</td>        <td width="91">1,619Kb</td>        <td width="180">1.62</td>        <td width="200">60.55</td>        <td width="87">37</td>     </tr>      <tr>       <td width="87">Yes</td>        <td width="91"><strong>3,238Kb</strong></td>        <td width="180"><strong>3.45</strong></td>        <td width="200"><strong>123.40</strong></td>        <td width="87"><strong>35</strong></td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">50Kb</td>        <td width="180">0.02</td>        <td width="200">0.34</td>        <td width="87">17</td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">101Kb</td>        <td width="180">0.07</td>        <td width="200">0.66</td>        <td width="87">9</td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">202Kb</td>        <td width="180">0.15</td>        <td width="200">1.28</td>        <td width="87">8</td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">405Kb</td>        <td width="180">0.48</td>        <td width="200">2.62</td>        <td width="87">5</td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">809Kb</td>        <td width="180">0.83</td>        <td width="200">5.26</td>        <td width="87">6</td>     </tr>      <tr>       <td width="87">No</td>        <td width="91">1,619Kb</td>        <td width="180">1.66</td>        <td width="200">10.57</td>        <td width="87">6</td>     </tr>      <tr>       <td width="87"><strong>No</strong></td>        <td width="91"><strong>3,237Kb</strong></td>        <td width="180"><strong>3.53</strong></td>        <td width="202"><strong>21.17</strong></td>        <td width="89"><strong>5</strong></td>     </tr>   </tbody></table>  <p>It should be possible to make this considerably faster still; since the code basically scans byte arrays, this is one of those areas where using pointer arithmetic could make a huge difference. I’ll dig out my unsafe hat and my pointer-gloves this weekend and see what I can do to it. In the meantime – play with it, experiment with it, but it’s probably a good idea not to let it within a hundred miles of your live servers :)</p>  