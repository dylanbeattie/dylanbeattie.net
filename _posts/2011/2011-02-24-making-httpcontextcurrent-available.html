---
layout: post
title: Making HttpContext.Current Available Within a WCF Service
date: '2011-02-24T14:28:00.001Z'
author: Dylan Beattie
tags: 
modified_time: '2011-02-24T14:28:57.218Z'
thumbnail: http://lh4.ggpht.com/_de7B8BtZZIw/TWZrKMGJMkI/AAAAAAAAAFo/jQgFzTDa8Co/s72-c/image_thumb%5B1%5D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-7295454224203070190.post-1225535335593713285
blogger_orig_url: http://www.dylanbeattie.net/2011/02/making-httpcontextcurrent-available.html
redirect_from: "/2011/02/making-httpcontextcurrent-available.html"

---

<p>I needed to add a quick’n’dirty WCF service to an ASP.NET MVC web application, so I could call a handful of methods from a different application.</p>  <p>The MVC app in question is using Windsor, NHibernate and the repository pattern, so we’ve got a fairly standard pattern where we spin up a ManagedWebSessionContext in the Application_BeginRequest handler (in global.asax.cs) and then flush and close the session in Application_EndRequest(). I used the Windsor WCF facility to inject a bunch of dependencies into a little WCF service, but I was finding that SessionFactory.GetCurrentSession() was always returning null – because when you’re using the ManagedWebSessionContext, your NHibernate session is bound to your HttpContext.Current, and by default you don’t have one of these inside a WCF service. </p>  <p>However - if you can live with tight coupling between your WCF service and IIS hosting, there’s a couple of little config things you’ll need to do to get this working. What doesn’t help is that until you’ve got all this just right, you’ll get a really helpful “Failed to Execute URL” error from IIS that’ll tell you absolutely nothing about what’s wrong.</p>  <p>First, make sure WCF HTTP activation is installed on your server – in Windows 2008, it’s under Server Manager –&gt; Features:</p>  <p>&#160;<a href="http://lh6.ggpht.com/_de7B8BtZZIw/TWZrJ6M0n4I/AAAAAAAAAFk/aSui0JLh5uI/s1600-h/image%5B3%5D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/_de7B8BtZZIw/TWZrKMGJMkI/AAAAAAAAAFo/jQgFzTDa8Co/image_thumb%5B1%5D.png?imgmax=800" width="525" height="484" /></a></p>  <p>Next, make sure you’ve registered the WCF service model with IIS, by running:</p>  <blockquote>   <p><font color="#a5a5a5">C:\WINDOWS\Microsoft.NET\Framework\v3.0\Windows Communication Foundation\&gt;</font> ServiceModelReg.exe –i</p> </blockquote>  <p>Next, make sure your web service is running in ASP.NET compatibility mode. First, check you’ve got this:</p>  <blockquote>   <p><font color="#a5a5a5">&lt;system.serviceModel&gt;       <br />&#160;&#160;&#160; &lt;serviceHostingEnvironment <font color="#000000"><strong>aspNetCompatibilityEnabled=&quot;true&quot;</strong></font> /&gt;        <br />&lt;/system.serviceModel&gt;</font></p> </blockquote>  <p>in your web.config file, and then decorate your service implementation with the AspNetCompatibilityRequirements attribute:</p>  <blockquote>   <p>[AspNetCompatibilityRequirements(RequirementsMode= AspNetCompatibilityRequirementsMode.Required)]     <br /><font color="#a5a5a5">public class WcfMagicService : IMagicService {       <br />&#160;&#160; . . .        <br />}</font></p> </blockquote>  <p>The last thing I had to do was necessitated by WCF not supporting multiple host headers; I had to hard-wire the WCF endpoint to listen on a specific hostname. In this case, this involved tweaking the serviceHostingEnvironment section of web.config, which now looks like this:</p>  <blockquote>   <p><font color="#a5a5a5">&lt;serviceHostingEnvironment aspNetCompatibilityEnabled=&quot;true&quot;&gt;       <br /></font>&#160;&#160;&#160; <strong>&lt;baseAddressPrefixFilters&gt;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;add prefix=http://services.mydomain.com” /&gt;        <br />&#160;&#160;&#160; &lt;/baseAddressPrefixFilters&gt;        <br /></strong><font color="#a5a5a5">&lt;/serviceHostingEnvironment&gt;</font></p> </blockquote>  <p>And then adding another attribute to the service implementation class:</p>  <blockquote>   <p><strong>[ServiceBehavior(AddressFilterMode=AddressFilterMode.Any)]       <br /></strong><font color="#a5a5a5">[AspNetCompatibilityRequirements(RequirementsMode= AspNetCompatibilityRequirementsMode.Required)]       <br />public class WcfMagicService : IMagicService {        <br />}</font></p> </blockquote>  <p>Once that’s done, you’ll have an instantiated HttpContext.Current inside your service methods, so your code – and useful things like NHibernate’s ManagedWebSessionContext – will behave just as they do in normal MVC controllers or WebForms code-behind.</p>  